# BIOS

- [Interrupt vector table][]
- [Software interrupts][]
- [Initialization][]
  - [Hard reset exclusive initialization][]
  - [Initialize registers, CPU, peripherals][]
    - [LCD][]
  - [Low battery check][]
  - [Development cartridge][]
  - [Copyright check][]
  - [Boot software][]
- [Screens][]
  - [Insert cartridge screen][]
  - [Low battery screen][]
  - [Game Select screen][]

[Interrupt vector table]: #interrupt-vector-table
[Software interrupts]: #software-interrupts
[Initialization]: #initialization
[Hard reset exclusive initialization]: #hard-reset-exclusive-initialization
[Initialize registers, CPU, peripherals]: #initialize-registers-cpu-peripherals
[LCD]: #lcd
[Low battery check]: #low-battery-check
[Development cartridge]: #development-cartridge
[Copyright check]: #copyright-check
[Boot software]: #boot-software
[Screens]: #screens
[Insert cartridge screen]: #insert-cartridge-screen
[Low battery screen]: #low-battery-screen
[Game Select screen]: #game-select-screen

The CPU contains a 4 KiB internal mask ROM holding the BIOS, which is mapped to the address range $0000-$1000. The PM's BIOS is the exact same ROM on every region's console.

Although the BIOS is not writable and the first $1000 bytes of the cartridge ROM are ignored, emulators have the capability to run a custom BIOS ROM. Pokemini ships with [freebios](https://github.com/pokemon-mini/pokemini/tree/master/freebios) and [NewBIOS](https://github.com/pokemon-mini/NewBIOS) is also available. This document will focus on the official BIOS, but all versions should be functionally compatible, but addresses for some functions may be different!

## Interrupt vector table

*For the full list of IRQs, see its [main page](interrupts.md)*

The table is a list of 2-byte absolute addresses into other parts of the BIOS. Because it's 2-byte, every `_int(0xkk)`/`INT [kkh]` instruction will be an even number. In previous documentation (and in PMAS) we instead used the index into the table instead of the address.

Interrupts $00 through $3E (inclusive) are for IRQs generated by the system. Interrupts $40 through $98 (inclusive) are software interrupts available for software to use via `_int` in C or `INT` in ASM. Calling interrupt $96 or anything strictly after $98 will cause undefined behavior.

As mentioned, IRQs go first through the BIOS then jump into [software](Memory.md#cartridge-memory). The cookie-cutter template for most of these middlemen is:

```s1c88
PUSH EP            ; backup the registers we change
PUSH BR
LD EP, #00h        ; paging register for [BR:ll] access
LD BR, #20h        ; set BR to access hardware registers
BIT [BR:01h], #20h ; if cart interrupts are not enabled, 
CARS Z, loc_0x0257 ; do something (unsure)
POP BR             ; restore backup registers before
POP EP             ; going into software
JRL 21xxh          ; jump to software IRQ handler
```

Some IRQs are unhandled and end up resetting the console without going into software (before resetting). Two IRQs have special handling related to sleeping the console: cart eject ($26) and power button ($2A), though the latter makes it to software.

## Software interrupts

*For the full list of hardware interrupts, see [here](interrupts.md)*

Althought they're all interrupts, we make a distinction between hardware interrupts and software interrupts. Hardware interrupts are interrupts triggered in response to requests from the hardware (IRQs) whereas software interrupts are only triggered from software via the `INT` operation.

The `INT` operation can also invoke hardware interrupts, ignoring the [interrupt flag](./README.md#interrupt-flags)'s setting. Since there's no need to ever do this, they're on their own page which can also talk about the hardware connectivity. Conversely, software interrupts are the correct way to execute BIOS-level procedures, which we discuss below.

| `INT [kk]` | Addr  | Description                                   |
| ---------- | ----- | --------------------------------------------- |
| [40h][]    | $FFF1 | Software-defined interrupt                    |
| [42h][]    | $0713 | Suspend system                                |
| [44h][]    | $077C | Sleep ??                                      |
| [46h][]    | $078B | Sleep with display on ??                      |
| [48h][]    | $079D | Shutdown system                               |
| [4Ah][]    | $07B1 | same as 44h                                   |
| [4Ch][]    | $07E9 | Set default LCD contrast                      |
| [4Eh][]    | $0802 | Step & apply default contrast                 |
| [50h][]    | $081B | Apply default LCD contrast                    |
| [52h][]    | $0821 | Get default contrast                          |
| [54h][]    | $0830 | Set temporary LCD contrast                    |
| [56h][]    | $084E | Turn LCD on                                   |
| [58h][]    | $0871 | Initialize LCD                                |
| [5Ah][]    | $08CB | Turn LCD off                                  |
| [5Ch][]    | $08EC | Enable RAM vector                             |
| [5Eh][]    | $0904 | Disable RAM vector                            |
| [60h][]    | $0923 | Disable cart eject IRQ+                       |
| [62h][]    | $092E | Enable cart eject IRQ+                        |
| [64h][]    | $0949 | Disable cart eject IRQ++                      |
| [66h][]    | $0961 | Enable cart eject IRQ++                       |
| [68h][]    | $097D | Flash cart: turn on and prepare selected game |
| [6Ah][]    | $09E4 | Flash cart: turn on and prepare autoboot game |
| [6Ch][]    | $0A4F | Enabled cart eject IRQ and set priority       |
| [6Eh][]    | $0A76 | Disable cart eject IRQ                        |
| [70h][]    | $0A81 | ??? weird                                     |
| [72h][]    | $0AA6 | Clock CPU with OSC3                           |
| [74h][]    | $0ACD | Clock CPU with OSC1 (low power mode)          |
| [76h][]    | $0AE6 | Power off cart slot                           |
| [78h][]    | $0AF9 | Power on cart slot                            |
| [7Ah][]    | $0B20 | Check cart inserted                           |
| [7Ch][]    | $0B2E | Execute test case ??                          |
| [7Eh][]    | $0B8F | Set PRC rate                                  |
| [80h][]    | $0BA3 | Get PRC rate                                  |
| [82h][]    | $0BB1 | Test $2001 bits 2~0 are a game struct ID      |
| [84h][]    | $047A | Flash cart: read product IDs                  |
| [86h][]    | $0493 | Flash cart: reset                             |
| [88h][]    | $04A4 | Flash cart: program byte                      |
| [8Ah][]    | $04C8 | Flash cart: erase sector                      |
| [8Ch][]    | $04F5 | Flash cart: enter bank select mode            |
| [8Eh][]    | $0506 | Flash cart: select bank                       |
| [90h][]    | $0517 | Flash cart: allow remapping page 0            |
| [92h][]    | $0529 | Flash cart: remap for reading product IDs     |
| [94h][]    | $053A | Select game by game struct ID                 |
| [96h][]    | $0000 | -                                             |
| [98h][]    | $0BBD | IR pulse                                      |

TODO: individual sections (pages?) on each software int

## Initialization

The BIOS can initialize from two points which we call a soft reset and a hard reset. A soft reset is when you wake up the console from sleeping. It goes to sleep when you push the power button while running a game, and reawakens if you push the power button again. A hard reset is when you remove the battery, reinsert, and then press the power button. TODO: what does the reset button do

1. [Hard reset exclusive initialization][]
2. [Initialize registers, CPU, peripherals][]
3. Decompress [screens][]' data
4. If there's no cartridge, go to the [insert cartridge screen][]
5. [Low battery check][]
6. Check if it's a [development cartridge][]
7. Run a [copyright check][]
8. [Boot software](#boot-software)

### Hard reset exclusive initialization

1. Reset and enable seconds counter
2. Set screen contrast to 50%
3. Reset RTC (TODO: re-evaluate)

### Initialize registers, CPU, peripherals

1. (soft reset) Initialize registers & CPU
2. Store startup keypad state to $14E1
3. Enable and power cartridge slot
4. Initialize voltage detector criteria [->](../../software/bios/disasm.md#user-content-018B)
5. Enable oscillators
6. Configure IRQs to defaults
7. Initialize I/O
8. Initialize LCD controller
9. Initialize cartridge
10. Enable exception handling globally (priority 3 only)
11. [Initialize LCD][LCD]

#### LCD

This represents the initial startup sequence for initializing the LCD. When turning the LCD on manually via `INT [56h]` the sequence has some slight differences.

1. Clear LCD display RAM [->](../../software/bios/disasm.md#user-content-00F4)
2. Read contrast from register $00 and send it to the LCD driver [->](../../software/bios/disasm.md#user-content-010E)
3. Disable LCD controller
4. Send [NOP](../lcd/cmd/21.md)
5. Send [setall off](../lcd/cmd/10.md)
6. Send [static indicator on and blink at half seconds](../lcd/cmd/19.md)
7. Send [end](../lcd/cmd/12.md)
8. Send [set display start line 0](../lcd/cmd/2.md)
9. Send [ADC select normal](../lcd/cmd/8.md)
10. Send [row direction normal](../lcd/cmd/15.md)
11. Send [color invert off](../lcd/cmd/9.md)
12. Send [power control all on](../lcd/cmd/16.md)
13. wait 349980 cycles (TODO: ms) [->](../../software/bios/disasm.md#user-content-08AA)
14. Send [display on](../lcd/cmd/1.md)

### Low battery check

*[Jump to code](../../software/bios/disasm.md#user-content-0120)*

1. Turns on the <abbr title="Supply Voltage Detection">SVD</abbr> circuit
2. Waits 200 cycles (docs require >= 100 Âµs)
3. Turns off the SVD to load the result into SVDDT
4. Reads SVDDT and goes to the low battery screen if it's a 1 (indicating the voltage is low)

Note that the required voltage was set earlier [here](../../software/bios/disasm.md#user-content-018B), which is likely looking for 3.3V but the exact voltage is unknown.

### Development cartridge

*For information on the dev cart, see [here](../dev_cart.md)*

*For the Game Select screen, see [here](#game-select-screen)*

### Copyright check

*[Jump to code](../../software/bios/disasm.md#user-content-nintendo_check)*

Checks for `NINTENDO` existing at $21A4 in cartridge ROM. The string it compares against is stored at [$0E1A](../../software/bios/disasm.md#user-content-nintendo_string)

If the check fails, it goes to the [Insert cartridge screen][].

### Boot software

1. Initialize LCD controller for software [->](../../software/bios/disasm.md#user-content-014A)
2. Reinitialize registers [->](../../software/bios/disasm.md#user-content-0157) [->](../../software/bios/disasm.md#user-content-016B)
3. Clear RAM (all $00) [->](../../software/bios/disasm.md#user-content-0161)
4. Store startup keypad state in B and cart type in A [->](../../software/bios/disasm.md#user-content-0159) [->](../../software/bios/disasm.md#user-content-016F)
5. Disable exception handling globally [->](../../software/bios/disasm.md#user-content-0173)
6. Jump to game entry point [->](../../software/bios/disasm.md#user-content-0175)

## Screens

The screen graphics and tilemaps are compressed and stored [here](../../software/bios/disasm.md#user-content-imgdata) with their animation data stored [here](../../software/bios/disasm.md#user-content-low_battery_animation).

To extract the graphics yourself, you may use the tool provided [here](../../software/bios/img_decoder.py)

The compression uses a simple <abbr title="Run Length Encoded">RLE</abbr> compression algorithm:

* 0xF9LL inserts LL+1 zeroes
* 0xFBXXLL inserts the byte 0xXX LL+1 times
* otherwise it copies the raw byte

The graphics data is loaded to $1530 all at once (it does not load the screen graphics on demand) [here](../../software/bios/disasm.md#user-content-decode_picture). The tilemaps start at $1650 and the tiles start at $1830. $1530 itself is a blank tilemap. These tilemaps are 5 rows of 12 tiles each, so slightly shorter than the full screen but the full width. When displayed, they're vertically centered onto the screen.

The [play animation](../../software/bios/disasm.md#user-content-play_animation) routine first loads the blank tilemap to clear the screen, then reads the animation description in order to load the specific screen.

The animation description uses the following format:

* Frame: 0bLLLLLLLA 0bAAAAAAAA
  * L = length in rendered frames
  * A = map address
* Footer: 0bSSSSSSSL 0bLLLLLLLL
  * S = number of bytes in the animation info
  * L = play time

Frames are in reverse order, that is: Frame N, ..., Frame 1, Frame 0. The animation repeats until the total play time specified in the footer is reached, then it shuts off the unit.

### Insert cartridge screen

The animation data contains 20 bytes + the footer and specifies a play time of 408 rendered frames. The frames decode to:

| Frame | Len | Addr |
| -----:| --- | ---- |
|     9 | 9   | $0B4 |
|     8 | 9   | $0F0 |
|     7 | 9   | $12C |
|     6 | 9   | $168 |
|     5 | 9   | $1A4 |
|     4 | 9   | $168 |
|     3 | 9   | $1A4 |
|     2 | 9   | $168 |
|     1 | 9   | $1A4 |
|     0 | 55  | $168 |

### Low battery screen

The animation data contains 6 bytes + the footer and specifies a play time of 288 rendered frames. The frames decode to:

| Frame | Len | Addr |
| -----:| --- | ---- |
|     2 | 30  | $000 |
|     1 | 12  | $03C |
|     0 | 6   | $078 |

### Game Select screen

A screen showcasing a game selection menu. It has no animations but is rather an interactive menu. A portion of this menu is preloaded but some in dynamically loaded once the BIOS decides it needs it.

The game names are pulled from the cartridge as 9 raw tile graphics, allowing for any styling of the name.

The menu GUI is a simple scrolling list. It starts at the top and allows the user to scroll down for 8 lines, displaying only 5 at a time. If an entry is off-screen, arrows indicate there are more above and/or below the current view.
