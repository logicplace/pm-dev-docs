{% asm "epson", 4 -%}
DEFSECT ".ram", DATA AT 14E0H
SECT ".ram"
	RemainingPlays:         DS 1
	KeyPad:                 DS 1
	NumGameStructs:         DS 1
	LoopN:                  DS 1
	GameStructs:            DS 64  ; array of 8-byte structures
	NextGameStruct:         DS 2
	NextTilePos:            DS 2
	CurrentRowStart:        DS 1
	FinalNameRowStartMin48: DS 1
	FinalNameRowStart:      DS 1
	MoveCooldown:           DS 1
	KeyHistory:             DS 1
	TotalAnimFrames:        DS 2
	FramesRemaining:        DS 1   ; "rendered frames" remaining for a frame
	BlankTilemap:           DS 96
	GameSelectMap:          DS 96
	GameNamesMap:           DS 96
	InsertCartMaps:         DS 180
	LowBatteryMaps:         DS 300
	TilesetBase:            DS 328
	VFlipStart  EQU  1920h
	VFlippedTiles:          DS 88
	GameNameTiles:          DS 576

DEFSECT ".bios", CODE AT 0000H
SECT ".bios"

	; Vector table
	DW _reset_vector
	DW _reset2
	DW _reset2
	DW _prc_frame_copy_irq
	DW _prc_render_irq
	DW _timer_2h_underflow_irq
	DW _timer_2l_underflow_irq
	DW _timer_1h_underflow_irq
	DW _timer_1l_underflow_irq
	DW _timer_3h_underflow_irq
	DW _timer_3_cmp_irq
	DW _timer_32hz_irq
	DW _timer_8hz_irq
	DW _timer_2hz_irq
	DW _timer_1hz_irq
	DW _ir_rx_irq
	DW _shake_irq
	DW _reset2
	DW _reset2
	DW _cart_eject_irq
	DW _cartridge_irq
	DW _key_power_irq
	DW _key_right_irq
	DW _key_left_irq
	DW _key_down_irq
	DW _key_up_irq
	DW _key_c_irq
	DW _key_b_irq
	DW _key_a_irq
	DW _unknown_irq0
	DW _unknown_irq1
	DW _unknown_irq2
	DW 0FFF1h
	DW _suspend_system
	DW _sleep
	DW _sleep_with_display
	DW _shutdown
	DW _sleep2
	DW _default_contrast
	DW _change_contrast
	DW _apply_default_contrast
	DW _get_default_contrast
	DW _set_temp_contrast
	DW _lcd_on
	DW _init_lcd
	DW _lcd_off
	DW _ena_ram_vec
	DW _dis_ram_vec
	DW _disable_cart_eject_irq_if
	DW _enable_cart_eject_irq_if
	DW _unknown_eject1
	DW _unknown_eject2
	DW _dev_card0
	DW _dev_card1
	DW _enable_cart_eject_irq
	DW _disable_cart_eject_irq
	DW _unknown_eject4
	DW _enter_high_speed_operation
	DW _enter_low_speed_operation
	DW _cart_slot_off
	DW _cart_slot_on
	DW _cart_detect
	DW _read_structure
	DW _set_prc_rate
	DW _get_prc_rate
	DW _game_id_valid
	DW _flash_read_ids
	DW _flash_reset
	DW _flash_program_byte
	DW _flash_erase_sector
	DW _flash_enter_bank_select_mode
	DW _flash_select_bank
	DW _flash_allow_remapping_page_0
	DW _flash_remap_ids
	DW _flash_prepare_game
	DW 0000h
	DW _ir_pulse

	hdr_nintendo EQU 21A4h

_reset_vector:
	LD EP, #00h                         ; address hardware registers
	LD BR, #20h                         ; ...
	LD [BR:08h], #02h                   ; reset seconds timer
	OR [BR:08h], #01h                   ; start seconds timer
	LD [BR:00h], #7Ch                   ; set default contrast to 31 (~50%)
	LD [BR:02h], #00h                   ; initialize to 0
_reset2:
	LD SC, #0C0h                        ; interrupt flags to NMI-only
	LD SP, #2000h                       ; initial stack location (end of RAM)
	CARL initregs                       ; initialize registers for BIOS's sake
	LD [BR:80h], A                      ; disable LCD controller (A=0)
	CARL enter_high_speed_operation     ; clock CPU with OSC3
	LD NB, #01h                         ; set default NB
	JRS copy_nb_to_cb
copy_nb_to_cb:
	LD A, [BR:52h]                      ; store initial keypad state
	LD [KeyPad], A                      ; to $14E1
	OR [BR:00h], #03h                   ; send Chip Enable (CE) signals
	LD [BR:01h], #30h                   ; ??
	OR [BR:02h], #0C0h                  ; ??
	CARL init_io
	LD [BR:80h], #02h                   ; enable tilemap (for BIOS screens)
	LD [BR:81h], #09h                   ; set frame divider to 2 and ?
	LD IX, #TilesetBase                 ; tileset base for the screens
	LD [02082h], IX                     ; ...
	LD [BR:84h], #00h                   ; ... (why not B? macro?)
	LD [BR:85h], B                      ; init map scroll to 0
	LD [BR:86h], B                      ; ...
	LD [BR:87h], B                      ; init sprite set base to 0
	LD [BR:88h], B                      ; ...
	LD [BR:89h], B                      ; ...
	CARL power_cart                     ; power the cartridge
	CARL wait_8000_cycles
	LD [BR:28h], #02h                   ; enable cart eject IRQ
	LD SC, #80h                         ; interrupt flags to IRQ3+
	LD [BR:0FEh], #0E3h                 ; send NOP command to LCD driver
	LD H, #0B0h                         ; set page 0 command
loop_from_B0_to_B8:                     ; loop through all display pages
	LD B, #60h                          ; 96 columns (screen width)
	LD [BR:0FEh], H                     ; send set page command
	LD [BR:0FEh], #10h                  ; send set column 0 command
	LD [BR:0FEh], #00h                  ; ...
clear_96_vertical_lines:
	LD [BR:0FFh], #00h                  ; clear column (and increment cursor)
	DJR NZ, clear_96_vertical_lines
	INC H                               ; next page
	CP H, #0B8h                         ; stop at last display page
	JRS NZ, loop_from_B0_to_B8
	CARL apply_default_contrast1
	XOR A, A                            ; delay between setup and display on
	CARL init_display
	CARL decode_picture                 ; load tiles/maps into RAM
	BIT [BR:53h], #02h                  ; check if cart is inserted
	JRS Z, check_voltage                ; 0=cart is inserted
	JRL insert_cart_screen              ; if no cart is inserted...
check_voltage:
	OR [BR:10h], #10h                   ; write 1 to SVDON
	LD B, #32h                          ; wait 202 cycles
cv__wait_200:
	DJR NZ, cv__wait_200
	AND [BR:10h], #~10h                 ; write 0 to SVDON
	BIT [BR:10h], #20h                  ; check battery level
	JRS Z, cv__sufficient               ; 0 = sufficient voltage supply
	CARL low_battery_screen
cv__sufficient:
	JRL check_cart_type
; ----------------------
nintendo_check:
	LD SP, #2000h
	LD B, #08h                          ; 8 letters in 'NINTENDO'
	LD IX, #hdr_nintendo                ; offset: start of 'NINTENDO' signature in game header
	LD IY, #nintendo_string             ; offset 0E1Ah: start of 'NINTENDO' field in BIOS, used for checking header
nc__loop:
	LD A, [IX]                          ; compare byte at IX with byte at IY
	CP A, [IY]                          ; ...
	JRL NZ, insert_cart_screen          ; if they're not the same, jump down to insert_cart_screen
	INC IX                              ; else, increment IX and IY to point to the next part of the 'NINTENDO' string
	INC IY                              ; ..
	DJR NZ, nc__loop                    ; and JDBNZ back to the start of the loop
prepare_boot:
	XOR A, A                            ; set A to 0
	LD [BR:80h], A                      ; set PRC_MODE to 0
	LD [BR:81h], #07h                   ; set PRC_RATE to 7
	LD [BR:82h], A                      ; set PRC_MAP LO and MID to 0
	LD [BR:83h], A                      ; ...
	AND [BR:01h], #~10h                 ; ??
	CARS initregs                       ; reset registers
	LD H, [KeyPad]                      ; load KEY_PAD into H (loaded into 0x14E1 by _reset_vector)
	LD L, [RemainingPlays]              ; load cart type into L
	LD IX, #1000h                       ; clear RAM
pb__loop:                               ; ...
	LD [IX], A                          ; ...
	INC IX                              ; ...
	CP IX, #2000h                       ; ...
	JRS NZ, pb__loop                    ; ...
	LD IX, BA                           ; clear registers
	LD BR, A                            ; ...
	LD BA, HL                           ; ...except forward info in BA
	LD HL, IX                           ; ...
	AND SC, #0C0h                       ; keep only interrupt flags
	JRL 2102h                           ; jump to game entrypoint
; ----------------------
; Returns:
;   BR: $20
;   BA, EP, XP, YP, HL, IX, IY: 0
initregs:
	LD BR, #20h                         ; set BR to 20 for hardware register area
	XOR A, A                            ; set all other general purpose registers to 0
	LD B, A                             ; ...
	LD EP, A                            ; ...
	LD XP, A                            ; ...
	LD YP, A                            ; ...
	LD HL, BA                           ; ...
	LD IX, BA                           ; ...
	LD IY, BA                           ; ...
	RET
; ----------------------
; Returns:
;   B: 0
; Clobbers: A
init_io:
	LD B, #00h
	LD [BR:10h], #08h                   ; set SYS_BATT to 8
	AND [BR:19h], #~30h                 ; disable OSC1/OSC3 for timer use
	LD [BR:20h], B                      ; set IRQ priorities to none (don't fire)
	LD [BR:21h], #30h                   ; ...except set cartridge IRQs to 3
	LD [BR:22h], #02h                   ; ...except set IR/shock to 2
	LD [BR:23h], B                      ; disable IRQs
	LD [BR:24h], #02h                   ; ...except cart eject IRQ
	LD [BR:25h], B                      ; ...
	LD [BR:26h], B                      ; ...
	LD [BR:40h], B                      ; disable clock timer
	LD [BR:44h], B                      ; ??
	LD [BR:50h], #0FFh                  ; set keypad IRQs to falling edge detection (on press)
	LD [BR:51h], B                      ; set cart eject and ? IRQs to rising edge (ejected)
	LD A, [BR:54h]                      ; set input level check time for ?? to 4ms?
	AND A, #~07h                        ; ...
	OR A, #01h                          ; ...
	LD [BR:54h], A                      ; ...
	LD [BR:55h], #01h                   ; set input level check time for ?? to 4ms?
	OR [BR:60h], #0Ch                   ; set EEPROM data/clock directions to output
	AND [BR:61h], #~04h                 ; set EEPROM data bit low
	OR [BR:61h], #08h                   ; set EEPROM clock bit high
	OR [BR:61h], #04h                   ; set EEPROM data bit high
	LD [BR:61h], #20h                   ; set all ports low except IR disable(?)
	LD [BR:60h], #32h                   ; IR disable(?), rumble, IR rx set to output
	LD [BR:62h], B                      ; ??
	LD [BR:70h], B                      ; ??
	LD [BR:71h], B                      ; ??
	RET
; ----------------------
_prc_frame_copy_irq:
	PUSH EP
	PUSH BR
	LD EP, #00h
	LD BR, #20h
	BIT [BR:01h], #20h                  ; if cart interrupts are not enabled,
	CARS Z, jrl1_intstuff               ; do something
	POP BR
	POP EP
	JRL 2108h                           ; jump to software handler
; ----------------------
_prc_render_irq:
	PUSH EP
	PUSH BR
	LD EP, #00h
	LD BR, #20h
	BIT [BR:01h], #20h
	CARS Z, jrl1_intstuff               ; same thing here
	POP BR
	POP EP
	JRL 210Eh                           ; jump to software handler
; ----------------------
_timer_2h_underflow_irq:
	PUSH EP
	PUSH BR
	LD EP, #00h
	LD BR, #20h
	BIT [BR:01h], #20h
	CARS Z, jrl1_intstuff               ; and here
	POP BR
	POP EP
	JRL 2114h                           ; jump to software handler
; ----------------------
_timer_2l_underflow_irq:
	PUSH EP
	PUSH BR
	LD EP, #00h
	LD BR, #20h
	BIT [BR:01h], #20h
	CARS Z, jrl1_intstuff
	POP BR
	POP EP
	JRL 211Ah                           ; jump to software handler
; ----------------------
_timer_1h_underflow_irq:
	PUSH EP
	PUSH BR
	LD EP, #00h
	LD BR, #20h
	BIT [BR:01h], #20h
	CARS Z, jrl1_intstuff               ; these all do the same thing
	POP BR
	POP EP
	JRL 2120h                           ; jump to software handler
; ----------------------
_timer_1l_underflow_irq:
	PUSH EP
	PUSH BR
	LD EP, #00h
	LD BR, #20h
	BIT [BR:01h], #20h
	CARS Z, jrl1_intstuff
	POP BR
	POP EP
	JRL 2126h                           ; jump to software handler
; ----------------------
_timer_3h_underflow_irq:
	PUSH EP
	PUSH BR
	LD EP, #00h
	LD BR, #20h
	BIT [BR:01h], #20h
	CARS Z, jrl1_intstuff
	POP BR
	POP EP
	JRL 212Ch                           ; jump to software handler
; ----------------------
_timer_3_cmp_irq:
	PUSH EP
	PUSH BR
	LD EP, #00h
	LD BR, #20h
	BIT [BR:01h], #20h
	CARS Z, jrl1_intstuff
	POP BR
	POP EP
	JRL 2132h                           ; jump to software handler
; ----------------------
jrl1_intstuff:
	JRL intstuff
; ----------------------
_timer_32hz_irq:
	PUSH EP
	PUSH BR
	LD EP, #00h
	LD BR, #20h
	BIT [BR:01h], #20h
	CARS Z, jrl1_intstuff
	POP BR
	POP EP
	JRL 2138h                           ; jump to software handler
; ----------------------
_timer_8hz_irq:
	PUSH EP
	PUSH BR
	LD EP, #00h
	LD BR, #20h
	BIT [BR:01h], #20h
	CARS Z, jrl1_intstuff
	POP BR
	POP EP
	JRL 213Eh                           ; jump to software handler
; ----------------------
_timer_2hz_irq:
	PUSH EP
	PUSH BR
	LD EP, #00h
	LD BR, #20h
	BIT [BR:01h], #20h
	CARS Z, jrl1_intstuff
	POP BR
	POP EP
	JRL 2144h                           ; jump to software handler
; ----------------------
_timer_1hz_irq:
	PUSH EP
	PUSH BR
	LD EP, #00h
	LD BR, #20h
	BIT [BR:01h], #20h
	CARS Z, jrl1_intstuff
	POP BR
	POP EP
	JRL 214Ah                           ; jump to software handler
; ----------------------
_ir_rx_irq:
	PUSH EP
	PUSH BR
	LD EP, #00h
	LD BR, #20h
	BIT [BR:01h], #20h
	CARS Z, jrl1_intstuff
	POP BR
	POP EP
	JRL 2150h                           ; jump to software handler
; ----------------------
_shake_irq:
	PUSH EP
	PUSH BR
	LD EP, #00h
	LD BR, #20h
	BIT [BR:01h], #20h
	CARS Z, jrl1_intstuff
	POP BR
	POP EP
	JRL 2156h                           ; jump to software handler
; ----------------------
_cartridge_irq:
	PUSH EP
	PUSH BR
	LD EP, #00h
	LD BR, #20h
	BIT [BR:01h], #20h
	CARS Z, jrl1_intstuff
	POP BR
	POP EP
	JRL 219Eh                           ; jump to software handler
; ----------------------
_key_right_irq:
	PUSH EP
	PUSH BR
	LD EP, #00h
	LD BR, #20h
	BIT [BR:01h], #20h
	CARS Z, jrl2_intstuff
	POP BR
	POP EP
	JRL 2162h                           ; jump to software handler
; ----------------------
_key_left_irq:
	PUSH EP
	PUSH BR
	LD EP, #00h
	LD BR, #20h
	BIT [BR:01h], #20h
	CARS Z, jrl2_intstuff
	POP BR
	POP EP
	JRL 2168h                           ; jump to software handler
; ----------------------
_key_down_irq:
	PUSH EP
	PUSH BR
	LD EP, #00h
	LD BR, #20h
	BIT [BR:01h], #20h
	CARS Z, jrl2_intstuff
	POP BR
	POP EP
	JRL 216Eh                           ; jump to software handler
; ----------------------
_key_up_irq:
	PUSH EP
	PUSH BR
	LD EP, #00h
	LD BR, #20h
	BIT [BR:01h], #20h
	CARS Z, jrl2_intstuff
	POP BR
	POP EP
	JRL 2174h                           ; jump to software handler
; ----------------------
_key_c_irq:
	PUSH EP
	PUSH BR
	LD EP, #00h
	LD BR, #20h
	BIT [BR:01h], #20h
	CARS Z, jrl2_intstuff
	POP BR
	POP EP
	JRL 217Ah                           ; jump to software handler
; ----------------------
_key_b_irq:
	PUSH EP
	PUSH BR
	LD EP, #00h
	LD BR, #20h
	BIT [BR:01h], #20h
	CARS Z, jrl2_intstuff
	POP BR
	POP EP
	JRL 2180h                           ; jump to software handler
; ----------------------
_key_a_irq:
	PUSH EP
	PUSH BR
	LD EP, #00h
	LD BR, #20h
	BIT [BR:01h], #20h
	CARS Z, jrl2_intstuff
	POP BR
	POP EP
	JRL 2186h                           ; jump to software handler
; ----------------------
_unknown_irq0:
	PUSH EP
	PUSH BR
	LD EP, #00h
	LD BR, #20h
	BIT [BR:01h], #20h
	CARS Z, jrl2_intstuff
	POP BR
	POP EP
	JRL 218Ch                           ; jump to software handler
; ----------------------
jrl2_intstuff:
	JRL intstuff
; ----------------------
_unknown_irq1:
	PUSH EP
	PUSH BR
	LD EP, #00h
	LD BR, #20h
	BIT [BR:01h], #20h
	CARS Z, jrl2_intstuff
	POP BR
	POP EP
	JRL 2192h                           ; jump to software handler
; ----------------------
_unknown_irq2:
	PUSH EP
	PUSH BR
	LD EP, #00h
	LD BR, #20h
	BIT [BR:01h], #20h
	CARS Z, jrl2_intstuff
	POP BR
	POP EP
	JRL 2198h                           ; jump to software handler
; ----------------------
; If you intend to wake the unit from something
; other than pressing the power key, write a JRL
; instruction to $1FFD before sleeping!
intstuff:
	BIT [BR:02h], #08h                  ; if clocking CPU with OSC3,
	JRS NZ, already_fast0               ; no need to start it up again
	PUSH SC
	LD SC, #0C0h                        ; interrupt flags to NMI-only
	CARL enter_high_speed_operation
	POP SC
already_fast0:
	BIT [BR:71h], #04h                  ; if cart is powered,
	JRS Z, loc_0x03A2                   ;
	BIT [BR:02h], #40h                  ; if ??,
	JRS Z, loc_0x03A2                   ;
	PUSH SC
	LD SC, #0C0h                        ; interrupt flags to NMI-only
	CARL power_cart
	BIT [BR:01h], #40h                  ; if ??,
	JRS Z, loc_0x03A1                   ;
	CARS prepare_selected_game
loc_0x03A1:
	POP SC
loc_0x03A2:
	BIT [BR:01h], #80h                  ; if ??,
	JRS Z, loc_0x03B0                   ;
	ADD SP, #0003h                      ; remove the call to this one
	POP BR                              ; restore BR/EP from interrupt's pushes
	POP EP                              ; ...
	JRL 1FFDh                           ; jump to RAM, hope it's another JRL!
; ----------------------
loc_0x03B0:
	PUSH SC
	LD SC, #0C0h                        ; interrupt flags to NMI-only
	CARS prepare_selected_game
	OR [BR:01h], #20h
	POP SC
	RET
; ----------------------
_key_power_irq:
	PUSH EP
	PUSH BR
	LD EP, #00h
	LD BR, #20h
	BIT [BR:01h], #20h
	JRS NZ, loc_0x0413
	BIT [BR:01h], #10h
	JRL NZ, _reset2
	BIT [BR:02h], #08h
	JRS NZ, already_fast1
	PUSH SC
	LD SC, #0C0h                        ; interrupt flags to NMI-only
	CARL enter_high_speed_operation
	POP SC
already_fast1:
	BIT [BR:71h], #04h                  ; if cartidge is powered,
	JRS Z, loc_0x03F0                   ; go to cart's handler
	BIT [BR:02h], #40h                  ; if ??,
	JRS Z, loc_0x03F0                   ; go to cart's handler
	PUSH SC
	LD SC, #0C0h                        ; interrupt flags to NMI-only
	CARL power_cart
	BIT [BR:01h], #40h
	JRS Z, loc_0x03EF
	CARS prepare_selected_game
loc_0x03EF:
	POP SC
loc_0x03F0:
	BIT [BR:01h], #80h
	JRS Z, loc_0x03FF
	BIT [BR:02h], #20h
	JRS NZ, loc_0x040D
	POP BR
	POP EP
	JRL 1FFDh                           ; jump to RAM, hope it's another JRL!
loc_0x03FF:
	PUSH SC
	LD SC, #0C0h                        ; interrupt flags to NMI-only
	CARS prepare_selected_game
	OR [BR:01h], #20h
	POP SC
	BIT [BR:02h], #20h
	JRS Z, loc_0x0413
loc_0x040D:
	LD [BR:29h], #80h
	POP BR
	POP EP
	RETE
loc_0x0413:
	POP BR
	POP EP
	JRL 215Ch
; ----------------------
; Clobbers: XP
prepare_selected_game:
	PUSH IP
	PUSH BA
	PUSH HL
	BIT [BR:01h], #08h                  ; if game ID is valid,
	JRS NZ, psg__use_game_id            ; use it
	BIT [BR:01h], #01h                  ; otherwise, if used startup action 2,
	JRS Z, psg__return
	LD L, #00h                          ; select game 0
	JRS psg__prepare_banks
psg__use_game_id:
	LD L, [BR:01h]                      ; load game ID into L
	AND L, #07h                         ; ...
psg__prepare_banks:
	LD XP, #07h                         ; set external page 1 to load bank 0
	LD A, #00h                          ; ...
	CARL flash_select_bank              ; ...
	LD A, L                             ; prepare select game's bank selections
	CARL flash_prepare_game             ; ...
psg__return:
	POP HL
	POP BA
	POP IP
	RET
; ----------------------
_cart_eject_irq:
	PUSH EP
	PUSH BR
	LD EP, #00h
	LD BR, #20h
	BIT [BR:01h], #30h
	JRL NZ, _reset2
	BIT [BR:02h], #08h
	JRS NZ, already_fast2
	PUSH SC
	LD SC, #0C0h                        ; interrupt flags to NMI-only
	CARL enter_high_speed_operation
	POP SC
already_fast2:
	BIT [BR:01h], #80h
	JRS Z, loc_0x0461
	BIT [BR:01h], #40h
	JRS Z, loc_0x0464
loc_0x0461:
	JRL _shutdown
loc_0x0464:
	BIT [BR:71h], #04h
	JRS Z, loc_0x0475
	BIT [BR:02h], #40h
	JRS Z, loc_0x0475
	PUSH SC
	LD SC, #0C0h                        ; interrupt flags to NMI-only
	CARL power_cart
	POP SC
loc_0x0475:
	POP BR
	POP EP
	JRL 1FFDh                           ; jump to RAM, hope it's another JRL!
; ----------------------
; Call _flash_remap_ids before this
; Reads 2100+ so that the reads make it to the cart
; making the temporary remapping necessary.
; Returns:
;   B: manufacturer ID
;   A: device ID
_flash_read_ids:
	POP SC
flash_read_ids:
	PUSH SC
	LD SC, #0C0h                        ; interrupt flags to NMI-only
	PUSH EP
	PUSH HL
	CARL flash_begin_cmd
	LD HL, #5555h
	LD [HL], #90h
	LD B, [2100h]
	LD A, [2101h]
	POP HL
	POP EP
	RETE
; ----------------------
_flash_reset:
	POP SC
flash_reset:
	PUSH SC
	LD SC, #0C0h                        ; interrupt flags to NMI-only
	PUSH EP
	PUSH HL
	CARL flash_begin_cmd
	LD HL, #5555h
	LD [HL], #0F0h
	POP HL
	POP EP
	RETE
; ----------------------
; Arguments
;   XP/IX: address to write to
;   A: byte to write
; Returns
;   A: -1 = write failed, 0 = success
; Clobbers: B
_flash_program_byte:
	POP SC
flash_program_byte:
	PUSH SC
	LD SC, #0C0h                        ; interrupt flags to NMI-only
	PUSH EP
	PUSH HL
	CARL flash_begin_cmd
	LD HL, #5555h                       ; final part of write unlock
	LD [HL], #0A0h                      ; ...
	LD [IX], A                          ; write byte
	LD H, #08h                          ; try 7x2 reads
fpb__wait_for_write:
	DEC H
	JRS NZ, fpb__wfw__unfinished
	LD A, #0FFh                         ; write failed
	JRS fpb__return
fpb__wfw__unfinished:
	LD B, [IX]                          ; check if byte was written correctly
	CP A, B                             ; ...
	JRS NZ, fpb__wait_for_write
	LD B, [IX]                          ; confirm it's not a data ghost ??
	CP A, B                             ; ...
	JRS NZ, fpb__wait_for_write
	XOR A, A                            ; write success
fpb__return:
	POP HL
	POP EP
	RETE
; ----------------------
; A sector is a 4 KiB section, uniformily placed.
; IX may contain any address in the section.
; The cleared sector is filled with 0xFF bytes.
; Arguments
;   XP/IX: sector to erase
; Clobbers: BA
_flash_erase_sector:
	LD SC, #0C0h                        ; interrupt flags to NMI-only
	PUSH EP
	PUSH HL
	CARL flash_begin_cmd
	LD HL, #5555h                       ; erase sequence
	LD [HL], #80h                       ; ...
	LD [HL], #0AAh                      ; ...
	LD HL, #2AAAh                       ; ...
	LD [HL], #55h                       ; ...
	LD [IX], #30h                       ; specify sector to erase
	LD A, #0FFh                         ; check for 0xFF to be written
	LD HL, #05001                       ; loop 5000 times
fes__wait_for_erase:
	DEC HL
	JRS NZ, loc_0x04E9
	LD A, #0FFh                         ; erase failed
	JRS loc_0x04F2
loc_0x04E9:
	; note that for any read while erase is still going
	; bit 7 will be 0 no matter the data at the location
	; you're reading from
	LD B, [IX]                          ; check if byte was erased correctly
	CP A, B                             ; ...
	JRS NZ, fes__wait_for_erase
	LD B, [IX]                          ; copypasta
	CP A, B                             ; ...
	JRS NZ, fes__wait_for_erase
	XOR A, A                            ; erase success
loc_0x04F2:
	POP HL
	POP EP
	RETE
; ----------------------
; Makes writes to $xxFFFF be interpreted as
; bank selects at the mapper level.
_flash_enter_bank_select_mode:
	POP SC
flash_enter_bank_select_mode:
	PUSH SC
	LD SC, #0C0h                        ; interrupt flags to NMI-only
	PUSH EP
	PUSH HL
	CARL flash_begin_cmd
	LD HL, #5555h                       ; send a command to the mapper
	LD [HL], #0D0h                      ; ...to unlock bank select
	POP HL
	POP EP
	RETE
; ----------------------
; Each bank is 256 KiB which is an addressing
; space of 0x040000. Thus the system can hold
; 8 banks. XP=7 with A=1 should be the default
; state while XP=7 with A=0 allows you to read
; from the first $2100 bytes of the cartridge
; by addressing data page 4, code page 8.
; Arguments
;   XP: Bank register to write to; 3+4*x
;   A: Value to write
_flash_select_bank:
	POP SC
flash_select_bank:
	PUSH SC
	LD SC, #0C0h                        ; interrupt flags to NMI-only
	CARL flash_enter_bank_select_mode   ; unlock bank registers
	PUSH IX
	LD IX, #0FFFFh                      ; write to bank select register
	LD [IX], A                          ; ...
	POP IX
	CARL flash_reset                    ; lock bank registers
	RETE
; ----------------------
; Without this, writing to 0x03FFFF bank select
; register is probably a NOP.
_flash_allow_remapping_page_0:
	POP SC
flash_allow_remapping_page_0:
	PUSH SC
	LD SC, #0C0h                        ; interrupt flags to NMI-only
	PUSH EP
	PUSH HL
	CARL flash_begin_cmd
	LD HL, #5555h
	LD [HL], #0C9h
	LD [HL], A
	POP HL
	POP EP
	RETE
; ----------------------
; Instructs the mapper to subtract $2100
; from the input address. Though it may
; not be generally usable in this state?
; This is used with ID mode to read info.
_flash_remap_ids:
	POP SC
flash_remap_ids:
	PUSH SC
	LD SC, #0C0h                        ; interrupt flags to NMI-only
	PUSH EP
	PUSH HL
	CARL flash_begin_cmd
	LD HL, #5555h
	LD [HL], #0C0h
	POP HL
	POP EP
	RETE
; ----------------------
; Prepares banks to run the game.
; Doesn't run the game itself.
; Arguments:
;   A: game ID (0-based)
; Clobbers: B
_flash_prepare_game:
	POP SC
flash_prepare_game:
	PUSH SC
	LD SC, #0C0h                        ; interrupt flags to NMI-only
	PUSH IP
	PUSH IX
	PUSH IY
	PUSH HL
	LD L, #60h                          ; size of game structure
	MLT                                 ; mlt to get addr in array
	LD IX, #1048h                       ; base address of structures + bank select array offset
	ADD IX, HL                          ; offset
	LD XP, #04h                         ; and read
	LD A, [IX]                          ; ...
	CP A, #08h                          ; if bank ID is >= 8,
	JRS NC, fsg__skip_remap_0           ; don't disable region 0
	CARL flash_allow_remapping_page_0
fsg__skip_remap_0:
	SUB SP, #0008h                      ; copy banks to heap
	LD YP, #00h                         ; ...
	LD IY, SP                           ; ...
	LD L, #00h                          ; ...
fsg__select_banks:
	LD A, [IX+L]                        ; copy bank ID from ROM
	LD [IY+L], A                        ; ...to heap
	INC L
	CP L, #08h                          ; there's 8 of them
	JRS NZ, fsg__select_banks
	CARL flash_enter_bank_select_mode
	LD A, #03h                          ; start at first bank select register
	LD IX, #0FFFFh                      ; bank select register address
fsg__bank_select_loop:
	LD XP, A
	LD B, [IY] 
	CP B, #08h                          ; if value is >= 8,
	JRS C, fsg__bsl__already_le8
	LD B, #08h                          ; cap to 8 (likely disables region)
fsg__bsl__already_le8:
	LD [IX], B
	INC IY
	ADD A, #04h                         ; increment to next bank select register
	CP A, #23h                          ; unless we hit the end,
	JRS NZ, fsg__bank_select_loop       ; keep going
	CARL flash_reset                    ; lock bank select registers
	LD SP, IY
	POP HL
	POP IY
	POP IX
	POP IP
	RETE
; ----------------------
; Common portion of a JEDEC SDP command sequence.
; Returns:
;   EP: $00
; Clobbers: HL
flash_begin_cmd:
	LD EP, #00h
	LD HL, #5555h
	LD [HL], #0AAh
	LD HL, #2AAAh
	LD [HL], #55h
	RET
; ----------------------
; Read cart information presuming it's a SST39LF/VF016 chip
; If it's not, perform some recovery.
; Returns:
;   Z: 0 = SST39LF/VF016, 1 = commercial game/other chip
; Clobbers: BA
flash_detect:
	LD B, [5555h]                       ; backup in case the chip is something else
	LD A, [2AAAh]                       ; ...
	PUSH BA
	LD A, #0FFh
	LD [2AAAh], A                       ; NOPs to clear state ??
	LD [2AAAh], A                       ; ...
	CARL flash_reset                    ; make sure device is in normal state
	CARL flash_remap_ids                ; have mapped read from $0000 when $2100 is requested
	CARL flash_read_ids                 ; read manufacturer/device ID into BA
	CARL flash_reset                    ; exit Software ID mode
	CP BA, #0BFD9h                      ; check manufacturer/device ID (SST39?F016)
	POP BA
	JRS Z, loc_0x05CA
	LD [5555h], B                       ; if it was an unexpected chip
	LD [2AAAh], A                       ; try to restore the data (NOP if ROM)
loc_0x05CA:
	LD A, [2AAAh]                       ; dummy read?
	RET
; ----------------------
check_cart_type:
	CARL flash_detect                   ; Z=0 if using a dev cart
	JRS NZ, cct__not_flash
	PUSH IP
	LD XP, #07h                         ; page register to write to
	LD A, #00h                          ; bank to select
	CARL flash_select_bank
	LD XP, #04h                         ; read startup action from cartridge
	LD IX, #1300h                       ; ...
	LD A, [IX]                          ; ...
	POP IP
	BIT A, #02h
	JRS NZ, cct__startup_action_2
	LD NB, #08h                         ; startup action 0 and 1,
	CARL 41400h                         ; call 0x041400 on cartridge
	LD [RemainingPlays], A              ; which returns the remaining plays in A
	JRL nintendo_check                  ; continue to boot
cct__startup_action_2:
	BIT A, #01h
	JRS NZ, game_select_menu
	XOR A, A                            ; startup action 2 picks the 0th slot
	CARL flash_prepare_game             ; ...
	OR [BR:01h], #01h                   ; remember that we used startup action 2
cct__not_flash:
	LD A, #0FFh                         ; normal carts, unexpected chips, and startup action 2,
	LD [RemainingPlays], A              ; unlimited play
	JRL nintendo_check                  ; continue to boot
game_select_menu:
	LD IX, #GameNameTiles               ; address right after the v-flipped decoded tile data
	XOR A, A                            ; 0-fill $19D0~$1C10 (exclusive)
gsm__clear:                             ; ...
	LD [IX], A                          ; ...
	INC IX                              ; ...
	CP IX, #1C10h                       ; ...
	JRS NZ, gsm__clear                  ; ...
	PUSH IP
	LD A, #04h                          ; read from data page 4 (region 1, bank 0)
	LD XP, A                            ; ...
	LD YP, A                            ; ...
	XOR A, A                            ; initialize memory
	LD [NumGameStructs], A              ; ...
	LD [LoopN], A                       ; ...
	LD HL, #GameStructs                 ; ...
	LD [NextGameStruct], HL             ; ...
	LD HL, #GameNameTiles               ; pointer to new tiles
	LD [NextTilePos], HL                ; ...
	LD IY, #1050h                       ; starting at type byte for entry 0
gsm__load_data_loop:
	LD A, [IY]                          ; read from $041050 (first loop)
	OR A, A                             ; if it's 0,
	JRL Z, gsm__ldl__end                ; skip entry
	CP A, #0FFh                         ; if it's -1,
	JRL Z, gsm__ldl__end                ; skip entry
	CP A, #0FEh                         ; if it's -2,
	JRS Z, gsm__ldl__load_data          ; load data/tiles
	LD IX, IY                           ; otherwise,
	INC IX                              ; read next byte
	LD A, [IX]                          ; ...
	BIT A, #80h                         ; if MSB is 1
	JRS NZ, gsm__ldl__loadable          ;
	XOR A, A                            ; otherwise write 0
	DEC IX                              ; to $041050 (first loop)
	CARL flash_program_byte
	OR A, A                             ; if byte was written successfully,
	JRL Z, gsm__ldl__end                ; skip entry
	POP IP                              ; otherwise,
	JRL insert_cart_screen
gsm__ldl__loadable:
	LD L, #00h                          ; number of 1-bits
	LD BA, IX                           ; ...from IX
	ADD BA, #15                         ; ...for 15 bytes
	PUSH BA
gsm__ldl__count_1s_in_byte:
	LD A, [IX]                          ; fetch byte
	LD B, #80h                          ; starting mask (MSB)
gsm__ldl__count_1_bits:
	BIT A, B                            ; if bit is 0,
	JRS Z, gsm__ldl__remove_bit         ; exit loop
	INC L                               ; number of 1-bits +1
	SRL B                               ; move to next bit
	JRS NZ, gsm__ldl__count_1_bits
	INC IX                              ; move to next byte
	POP BA                              ; restore end address for check
	PUSH BA                             ; ...
	CP BA, IX                           ; ...
	JRS NZ, gsm__ldl__continue_counting ; continue if we haven't hit it (exclusive)
	LD B, #80h                          ; reset mask to MSB for check below
	JRS gsm__ldl__remove_bit
gsm__ldl__continue_counting:
	JRS gsm__ldl__count_1s_in_byte      ; could've just jumped straight there...
gsm__ldl__remove_bit:
	RLC B                               ; if we got here from any bit but the MSB being 0,
	CP B, #01h                          ; these would not be equal,
	JRS NZ, loc_0x067F                  ; so we don't dec IX
	DEC IX                              ; otherwise, dec IX back to the last 0xFF byte (IX+15)
loc_0x067F:
	CPL B                               ; mask everything but bit before the "0"
	LD A, [IX]                          ; reload in case we decremented
	AND A, B                            ; ...
	LD H, A                             ; cases:
	                                    ; 01 80   -> H = 0x00
	                                    ; 01 FF08 -> H = 0xFE
	                                    ; 01 FFF8 -> H = 0xF0
	                                    ; 01 FFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFF -> H = 0xFE
	POP BA
	LD B, H
	DEC L                               ; number of 1-bits -1
	LD A, L                             ; ...
gsm__ldl__load_data:
	PUSH BA
	LD A, [NumGameStructs]              ; loading 1 more struct
	INC A                               ; ...
	LD [NumGameStructs], A              ; ...
	LD HL, [NextGameStruct]             ; where we're loading the data to
	LD A, [LoopN]                       ; $00 - index on cart
	LD [HL], A                          ; ...
	INC HL
	POP BA
	LD [HL], A                          ; 0xFE or number of 1-bits - 1
	INC HL
	LD [HL], B                          ; garbage byte or ?? (see above)
	INC HL
	LD [HL], IX                         ; $1C10 (first loop if 0xFE) or location of byte in B
	ADD HL, #5                          ; two bytes from the above addr + 3 slop
	LD [NextGameStruct], HL             ; store addr for next entry
	LD HL, [NextTilePos]                ; where we're loading tile gfx to
	LD IX, IY                           ; $041050 (first loop)
	LD B, #72                           ; read 9 tiles (72 bytes)
	SUB IX, #0050h                      ; $041000 (first loop)
gsm__ldl__load_name_tiles:
	LD [HL], [IX]                       ; load in tile
	INC HL                              ; next
	INC IX                              ; ...
	DJR NZ, gsm__ldl__load_name_tiles
	LD [NextTilePos], HL                ; store addr for next entry
gsm__ldl__end:
	ADD IY, #0060h                      ; $0410B0 (first loop)
	LD A, [LoopN]                       ; increment loop count
	INC A                               ; ...
	LD [LoopN], A                       ; ...
	CP A, #08h                          ; if we haven't looped 8 times,
	JRL NZ, gsm__load_data_loop         ; keep going
	POP IP
	LD A, [NumGameStructs]              ; check if any data was loaded
	OR A, A                             ; and if so,
	JRS NZ, gsm__games_available        ; show screen
	JRL insert_cart_screen              ; otherwise
gsm__games_available:
	OR [BR:01h], #08h                   ; ??
	JRL game_select_screen
; ----------------------
; This is jumped to not called
; Arguments:
;   A: game index (in RAM table)
; Clobbers: any
run_selected_game:
	SLL A                               ; multiply index by 8 (size of a game struct in memory)
	SLL A                               ; ...
	SLL A                               ; ...
	LD B, #00h                          ; indexing into game structs array
	LD IY, #GameStructs                 ; ...
	ADD IY, BA                          ; ...
	LD H, [IY]                          ; ...read index in list on cart to H
	INC IY
	LD B, [IY]                          ; 0xFE or number of 1-bits - 1
	LD [RemainingPlays], B              ; ...to cart type???
	CP B, #0FEh                         ; if it's -2,
	JRS Z, loc_0x0706                   ; skip write out
	INC IY
	LD A, [IY]                          ; ??
	INC IY
	LD IX, [IY]                         ; original location of A
	PUSH IP
	LD XP, #04h                         ; write masked byte
	CARL flash_program_byte             ; ...
	POP IP
	OR A, A                             ; if it wasn't written successfully,
	JRL NZ, insert_cart_screen          ; exit
loc_0x0706:
	LD B, [BR:01h]
	LD A, H                             ; game index to load
	OR A, B                             ; TODO: confirm if line $00C7 makes this safe every time
	LD [BR:01h], A
	LD A, H
	CARL flash_prepare_game
	JRL nintendo_check
; ----------------------
; Clobbers: BA
_suspend_system:
	PUSH EP
	PUSH BR
	LD SC, #0C0h                        ; interrupt flags to NMI-only
	CARL set_br
	OR [BR:02h], #20h
	; back up registers that will be changed
	LD A, [BR:80h]                      ; back up LCD controller config
	PUSH BA                             ; ...
	LD B, [BR:50h]                      ; back up input polarities (except cart slot)
	LD A, [BR:21h]                      ; back up keypad IRQ priorities
	AND A, #0Ch                         ; ...
	PUSH BA                             ; ...
	LD B, [BR:23h]                      ; back up IRQ enable status
	LD A, [BR:24h]                      ; ...
	PUSH BA                             ; ...
	LD B, [BR:25h]                      ; ...
	LD A, [BR:26h]                      ; ...
	PUSH BA                             ; ...
	; When called directly, this needs to be a shutdown sequence
	; See _shutdown for requirements
do_shutdown:
	LD [BR:50h], #80h                   ; leave power as falling edge, others to rising edge
	LD [BR:54h], #01h                   ; set input level check time for ?? to 4ms?
	LD [BR:23h], #00h                   ; disable IRQs
	LD [BR:24h], #00h                   ; ...
	LD [BR:25h], #80h                   ; ...except power key
	LD [BR:26h], #00h                   ; ...
	OR [BR:21h], #0Ch                   ; power key IRQ priority to 3
	CARL wait_8000_cycles
	LD [BR:29h], #80h                   ; clear power key IRQ
	LD A, #80h                          ; set interrupt flags to 2 before halt
	CARL halt_cpu_and_lcd
	; After resuming from halt (if that's possible!)
resume:
	CARL lcd_on
	AND [BR:02h], #~20h
	; restore registers after awakening
	POP BA                              ; restore IRQ enable status
	LD [BR:26h], A                      ; ...
	LD [BR:25h], B                      ; ...
	POP BA                              ; ...
	LD [BR:23h], B                      ; ...
	BIT [BR:01h], #40h                  ; ??
	JRS Z, r__trust_24
	OR A, #02h                          ; ...also enable cart eject IRQ
r__trust_24:
	LD [BR:24h], A                      ; ...
	POP A
	LD B, [BR:21h]                      ; only add back keypad IRQ priorities
	AND B, #~0Ch                        ; ...
	OR A, B                             ; ...
	LD [BR:21h], A                      ; ...
	POP B                               ; restore input polarities (except cart slot)
	LD [BR:50h], B                      ; ...
	POP BA                              ; restore LCD controller config
	LD [BR:80h], A                      ; ...
	POP BR
	POP EP
	RETE
; ----------------------
_sleep:
	PUSH EP
	PUSH BR
	LD SC, #0C0h                        ; interrupt flags to NMI-only
	CARL set_br
	LD A, #40h                          ; set interrupt flags to 1 before halt
	CARL halt_cpu_and_lcd
	POP BR
	POP EP
	RETE
; ----------------------
_sleep_with_display:
	PUSH EP
	PUSH BR
	LD SC, #0C0h                        ; interrupt flags to NMI-only
	CARL set_br
	AND [BR:80h], #~08h                 ; disable LCD controller
	LD A, #40h                          ; set interrupt flags to 1 before halt
	CARL halt_cpu
	POP BR
	POP EP
	RETE
; ----------------------
; Power button resets system after this.
_shutdown:
	LD SC, #0C0h                        ; interrupt flags to NMI-only
	LD SP, #2000h
	CARL set_br
	CARL init_io
shutdown:
	LD SC, #0C0h                        ; interrupt flags to NMI-only
	LD [BR:01h], #90h
	JRL do_shutdown
; ----------------------
; Same as _sleep just lines 3 and 4 swapped...
; Official software uses _sleep rather than this.
_sleep2:
	PUSH EP
	PUSH BR
	CARL set_br
	LD SC, #0C0h                        ; interrupt flags to NMI-only
	LD A, #40h                          ; set interrupt flags to 1 before halt
	CARL halt_cpu_and_lcd
	POP BR
	POP EP
	RETE
; ----------------------
; Arguments:
;   A copied to SC right before HALT
halt_cpu_and_lcd:
	CARL lcd_off
halt_cpu:
	BIT [BR:01h], #80h
	JRS Z, hc__wake_on_cart
	BIT [BR:01h], #40h
	JRS Z, hc__halt_sequence
hc__wake_on_cart:                       ; ejected? inserted?
	OR [BR:24h], #02h                   ; enable cart eject IRQ
	OR [BR:21h], #30h                   ; set cartridge IRQs' priorities to 3
hc__halt_sequence:
	AND [BR:51h], #~02h                 ; set cart eject IRQ to rising edge (ejected)
	LD [BR:55h], #01h                   ; set input level check time for ?? to 4ms?
	AND [BR:01h], #~20h
	CARL unpower_cart
	CARL enter_low_speed_operation
	LD SC, A
	HALT
	LD SC, #0C0h                        ; interrupt flags to NMI-only
	RET
; ----------------------
; Stores and applies a contrast value which can be
; restored with _apply_default_contrast (INT [50h]).
; Default set by the BIOS is 31.
; Arguments:
;   A: new default contrast, 0~63
; Clobbers: B
_default_contrast:
	POP SC
default_contrast:
	SLL A
	SLL A
	PUSH EP
	PUSH HL
	LD EP, #00h
	LD HL, #2000h
	AND [HL], #03h
	OR [HL], A
	POP HL
	POP EP
	CARL get_default_contrast
	JRS set_temp_contrast
; ----------------------
; Step contrast up or down based on Z
; Arguments:
;   Z: 0 = decrement, 1 = increment
; Returns:
;   A: -1 = fail, 0 = success
; Clobbers: B
_change_contrast:
	CARL get_default_contrast
	POP SC
	PUSH SC
	JRS Z, cc__try_decrement            ; decrement if Z=0
	CP A, #03Fh                         ; if contrast is already max,
	JRS Z, cc__fail                     ; fail out
	INC A                               ; Z=1 so increment
cc__set_and_return:
	CARS default_contrast               ; store and apply
	XOR A, A                            ; return success
	RETE
cc__try_decrement:
	OR A, A                             ; if A > 0,
	JRS NZ, cc__decrement               ; decrement
cc__fail:
	LD A, #0FFh                         ; return failure (already max or min)
	RETE
cc__decrement:
	DEC A
	JRS cc__set_and_return
; ----------------------
; Returns:
;   A: contrast
; Clobbers: B
_apply_default_contrast:
	POP SC
apply_default_contrast1:
	CARL get_default_contrast
	JRS set_temp_contrast
; ----------------------
; Returns:
;   A: contrast
_get_default_contrast:
	POP SC
get_default_contrast:
	PUSH EP
	PUSH BR
	CARL set_br
	LD A, [BR:00h]
	SRL A
	SRL A
	POP BR
	POP EP
	RET
; ----------------------
; Arguments:
;   A: new contrast, 0~63
; Clobbers: B
_set_temp_contrast:
	POP SC
set_temp_contrast:
	PUSH EP
	PUSH BR
	CARL set_br
	LD B, A
	BIT [BR:80h], #08h                  ; store whether or not LCD controller was enabled
	LD A, SC                            ; ...
	AND [BR:80h], #~08h                 ; disable LCD controller
	LD [BR:0FEh], #81h                  ; send contrast command
	LD [BR:0FEh], B                     ; ...
	LD SC, A                            ; if LCD controller was enabled,
	JRS Z, stc__return
	OR [BR:80h], #08h                   ; re-enable it
stc__return:
	POP BR
	POP EP
	RET
; ----------------------
_lcd_on:
	POP SC
	PUSH EP
	PUSH BR
	CARL set_br
	CARS lcd_on
	POP BR
	POP EP
	RET
; Clobbers: BA
lcd_on:
	PUSH SC
	LD SC, #0C0h                        ; interrupt flags to NMI-only
	BIT [BR:02h], #04h                  ; ??
	JRS Z, lcdo__reset_02_bit4
	OR [BR:02h], #10h                   ; ??
	JRS lcdo__return
lcdo__reset_02_bit4:
	AND [BR:02h], #~10h                 ; ??
lcdo__return:
	OR [BR:81h], #01h                   ; ??
	XOR A, A                            ; wait between power cfg and on commands
	CARL init_display
	RETE
; ----------------------
; Clobbers: BA
_init_lcd:
	POP SC
	PUSH EP
	PUSH BR
	CARL set_br
	CARS init_display_without_wait
	POP BR
	POP EP
	RET
; ----------------------
; Clobbers: BA
init_display_without_wait:
	LD A, #0FFh
; Arguments
;   A: 0 = wait, non-zero = don't wait
; Clobbers: B
init_display:
	PUSH SC                             ; back up SC
	LD SC, #0C0h                        ; interrupt flags to NMI-only
	BIT [BR:81h], #01h                  ; ??
	JRS NZ, id__init
	RETE                                ; restore SC and return
id__init:
	PUSH HL
	LD HL, #20FEh                       ; using [HL] is less bytes than [BR:ll] for all
	LD B, [BR:80h]                      ; back up LCD controller config
	AND [BR:80h], #~08h                 ; disable LCD controller
	LD [HL], #0E3h                      ; send NOP
	LD [HL], #0A4h                      ; send "set all on" off
	LD [HL], #0ADh                      ; send enable static indicator
	LD [HL], #02h                       ; blink static indicator at half second intervals
	LD [HL], #0EEh                      ; send RMW end
	LD [HL], #40h                       ; send set display start line 0
	LD [HL], #0A2h                      ; send LCD bias 1/9
	LD [HL], #0A0h                      ; send ADC select normal
	LD [HL], #0C0h                      ; send row direction normal
	LD [HL], #0A6h                      ; send color invert off
	LD [HL], #02Fh                      ; send power supply circuits all on
	OR A, A                             ; A=0 do wait, Aâ‰ 0 don't wait
	JRS NZ, loc_0x08C5
	PUSH IX
	BIT [BR:02h], #08h                  ; check what oscillator is clocking the CPU
	JRS NZ, id__using_hso
	LD A, #01h                          ; wait 5711 cycles (from start of loop)
	LD IX, #0592h                       ; ...
	JRS id__wait_for_warmup
id__using_hso:
	LD A, #02h                          ; wait 349978 cycles (from start of loop)
	LD IX, #55C4h                       ; ...
id__wait_for_warmup:
	DEC IX
	JRS NZ, id__wait_for_warmup
	LD IX, #0FFFFh
	DEC A                               ; exit at 0, so A=1 doesn't do extra
	JRS NZ, id__wait_for_warmup
	POP IX
loc_0x08C5:
	LD [HL], #0AFh                      ; send display on
	LD [BR:80h], B                      ; restore frame copy state
	POP HL
	RETE
; ----------------------
_lcd_off:
	POP SC
	PUSH EP
	PUSH BR
	CARL set_br
	CARS lcd_off
	POP BR
	POP EP
	RET
lcd_off:
	PUSH SC                             ; back up flags
	LD SC, #0C0h                        ; interrupt flags to NMI-only
	AND [BR:80h], #~08h                 ; disable LCD controller
	LD [BR:0FEh], #0AEh                 ; send display off
	LD [BR:0FEh], #0ACh                 ; send static indicator off
	LD [BR:0FEh], #28h                  ; send power supply circuits all off
	LD [BR:0FEh], #0A5h                 ; send "set all on" on (enter _sleep mode)
	AND [BR:81h], #~01h                 ; ??
	RETE                                ; restore flags
; ----------------------
_ena_ram_vec:
	PUSH EP
	PUSH BR
	CARL set_br
	LD SC, #0C0h                        ; interrupt flags to NMI-only
	BIT [BR:01h], #80h                  ; if bit 7 is already set,
	JRS NZ, loc_0x0901                  ; skip
	OR [BR:01h], #80h                   ; otherwise set it
	OR [BR:01h], #40h                   ; and bit 6
	AND [BR:01h], #~20h                 ; and reset bit 5
loc_0x0901:
	POP BR
	POP EP
	RETE
; ----------------------
_dis_ram_vec:
	PUSH EP
	PUSH BR
	CARL skip_if_01_not_bit6
	LD [BR:55h], #01h
	AND [BR:51h], #~02h
	LD SC, #0C0h                        ; interrupt flags to NMI-only
	OR [BR:21h], #30h
	OR [BR:24h], #02h                   ; enable cart eject IRQ
	OR [BR:01h], #20h
	AND [BR:01h], #~40h
	AND [BR:01h], #~80h
	POP BR
	POP EP
	RETE
; ----------------------
_disable_cart_eject_irq_if:
	PUSH EP
	PUSH BR
	CARL skip_if_01_not_bit6
	AND [BR:24h], #~02h                 ; disable cart eject IRQ
	POP BR
	POP EP
	RETE
; ----------------------
_enable_cart_eject_irq_if:
	PUSH EP
	PUSH BR
	CARL skip_if_01_not_bit6
	OR [BR:24h], #02h                   ; enable cart eject IRQ
	POP BR
	POP EP
	RETE
; ----------------------
; MUST push EP, BR, SC (maybe from INT) before calling
skip_if_01_not_bit6:
	CARL set_br
	BIT [BR:01h], #40h                  ; if bit 6 is set,
	JRS NZ, si__return                  ; just return
	ADD SP, #0003h                      ; otherwise return back to caller's caller
	POP BR                              ; and give BR/EP/SC back
	POP EP                              ; ...
	RETE                                ; ...
; ----------------------
si__return:
	RET
; ----------------------
_unknown_eject1:
	PUSH EP
	PUSH BR
	CARL set_br
	LD SC, #0C0h                        ; interrupt flags to NMI-only
	BIT [BR:01h], #80h                  ; if bit 7 is set,
	JRS NZ, loc_0x095E                  ; just return
	AND [BR:24h], #~02h                 ; otherwise, disable cart eject IRQ
	OR [BR:01h], #80h                   ; set bit 7
	AND [BR:01h], #~20h                 ; and reset bit 5
loc_0x095E:
	POP BR
	POP EP
	RETE
; ----------------------
_unknown_eject2:
	PUSH EP
	PUSH BR
	CARL skip_if_01_bit6_or_not_bit7
	LD [BR:55h], #01h                   ; set input level check time for ?? to 4ms?
	AND [BR:51h], #~02h                 ; set cart eject IRQ to rising edge (ejected)
	LD SC, #0C0h                        ; interrupt flags to NMI-only
	OR [BR:21h], #30h                   ; set cartridge IRQs' priorities to 3
	OR [BR:24h], #02h                   ; enable cart eject IRQ
	OR [BR:01h], #20h                   ; set bit 5
	AND [BR:01h], #~80h                 ; reset bit 7
	POP BR
	POP EP
	RETE
; ----------------------
; Similar to prepare_selected_game but:
;   Conditional execution.
;   Does not assume cart is inserted or powered.
;   Check startup action instead of $2001.3~0 being 0b0xx1.
;   Ensures the game struct in ROM is valid.
; When this returns 0, it leaves the cart powered.
; Returns:
;   A:
;     0 = banks perpared
;     1 = no cart inserted
;     2 = error:
;           unexpected game ID in $2001
;           expected game ID in $2001
;           selected game ID has no valid entry in ROM
; Clobbers: B, XP
_dev_card0:
	PUSH EP
	PUSH BR
	LD SC, #0C0h                        ; interrupt flags to NMI-only
	CARL skip_if_01_bit6_or_not_bit7
	PUSH IX
	PUSH HL
	BIT [BR:53h], #02h                  ; if cart is inserted,
	JRS Z, dc0__cart_inserted           ; continue
	LD A, #01h                          ; otherwise, return 1
	JRS dc0__return1
dc0__cart_inserted:
	LD B, [BR:80h]                      ; back up LCD controller settings
	LD [BR:80h], #00h                   ; disable LCD controller
	LD A, [BR:71h]                      ; back up cart power/volume
	PUSH BA                             ; ...
	CARL power_cart
	CARL wait_8000_cycles
	LD [BR:28h], #02h                   ; clear cart eject IRQ
	CARL select_boot
	JRS NZ, dc0__verify_selected_game   ; 0 = banks were selected (or didn't need to be)
	BIT [BR:01h], #08h                  ; we don't expect a valid game index in this case so,
	JRS NZ, dc0__return3                ; return 2
	JRS dc0__leave_powered
dc0__verify_selected_game:
	BIT [BR:01h], #08h                  ; if bits 2~0 don't contain a game index,
	JRS Z, dc0__return3                 ; return 2
	LD A, [BR:01h]                      ; otherwise, load the game index
	AND A, #07h                         ; ...
	LD L, #60h                          ; size of a game struct
	MLT                                 ; ...
	LD IX, #1050h                       ; read from $041050 + 96 * ?
	ADD IX, HL                          ; ...
	PUSH IP                             ; ...
	LD XP, #04h                         ; ...
	LD B, [IX]                          ; ...
	POP IP                              ; ...
	CP B, #00h                          ; if it's 0 (empty),
	JRS Z, dc0__return3                 ; return 2
	CP B, #0FFh                         ; if it's 0xff (erased),
	JRS Z, dc0__return3                 ; return 2
	CARL flash_prepare_game             ; otherwise select game in A
dc0__leave_powered:
	OR [BR:02h], #40h                   ; ??
	POP BA
	XOR A, A                            ; return 0
	JRS dc0__return2                    ; leave cart powered
dc0__return3:
	POP BA
	LD [BR:71h], A                      ; restore cart power/volume
	LD A, #02h                          ; return 2
dc0__return2:
	LD [BR:80h], B                      ; restore LCD controller settings
dc0__return1:
	POP HL
	POP IX
	POP BR
	POP EP
	RETE
; ----------------------
; Prepares bank selections only if cart is inserted
; and startup action is 0/2 (or not a dev cart).
; Powers on cart if one's inserted.
; Clobbers: BA, XP
_dev_card1:
	PUSH EP
	PUSH BR
	LD SC, #0C0h                        ; interrupt flags to NMI-only
	CARL skip_if_01_bit6_or_not_bit7
	LD B, [BR:80h]                      ; back up LCD controller config
	LD [BR:80h], #00h                   ; disable LCD controller
	PUSH B
	PUSH IX
	PUSH HL
	BIT [BR:53h], #02h                  ; if cart is inserted,
	JRS Z, dc1__prepare_autoboot_only   ; ...
	LD A, #01h                          ; otherwise return 1
	JRS dc1__return
dc1__prepare_autoboot_only:
	CARL cart_slot_on
	CARL select_boot
	JRS Z, dc1__return                  ; done selecting banks, so return
	PUSH IP
	LD XP, #07h                         ; set external page 1 to load bank 1
	LD A, #01h                          ; ...
	CARL flash_select_bank              ; ...
	POP IP
	LD A, #0FFh                         ; return -1
dc1__return:
	POP HL
	POP IX
	POP B
	LD [BR:80h], B
	POP BR
	POP EP
	RETE
; ----------------------
; MUST push EP, BR, SC (maybe from INT) before calling
skip_if_01_bit6_or_not_bit7:
	CARL set_br
	BIT [BR:01h], #80h                  ; if bit 7 is 0,
	JRS Z, si2__do_skip                 ; perform skip
	BIT [BR:01h], #40h                  ; if bit 6 is 0,
	JRS Z, si2__return                  ; don't skip
si2__do_skip:
	ADD SP, #0003h
	POP BR
	POP EP
	RETE
; ----------------------
si2__return:
	RET
; ----------------------
; If the startup action bit 0 is 0, prepare game 0.
; Otherwise, do further checks.
; Returns:
;   Z: 0 = ready to boot, 1 = do more checks
; Clobbers: A, XP, IX
select_boot:
	CARL flash_detect
	JRS NZ, sb__return_fail             ; if it's not a flash cart
	PUSH IP
	LD XP, #07h                         ; bank register
	LD A, #00h                          ; value to write
	CARL flash_select_bank
	LD XP, #04h                         ; read startup action
	LD IX, #1300h                       ; ...
	LD A, [IX]                          ; ...
	POP IP
	BIT A, #01h                         ; if it's 0,
	JRS NZ, sb__return
	XOR A, A                            ; start the first game automatically
	CARL flash_prepare_game             ; ...
sb__return_fail:
	XOR A, A                            ; fail out
sb__return:
	RET
; ----------------------
; Arguments:
;   A: cart eject IRQ priority
; Clobbers: B
_enable_cart_eject_irq:
	POP SC
	PUSH EP
	PUSH BR
	CARL set_br
	SWAP A
	AND A, #30h
	PUSH SC
	LD SC, #0C0h                        ; interrupt flags to NMI-only
	LD B, [BR:21h]                      ; get IRQ priorities
	AND B, #0CFh                        ; clear cart eject's
	OR A, B                             ; set it to value in A
	LD [BR:21h], A                      ; ...
	POP SC
	LD [BR:55h], #01h                   ; set input level check time for ?? to 4ms?
	AND [BR:51h], #~02h                 ; set cart eject IRQ to rising edge (ejected)
	CARL wait_8000_cycles
	LD [BR:28h], #02h                   ; clear cart eject
	OR [BR:24h], #02h                   ; enable cart eject IRQ
	POP BR
	POP EP
	RET
; ----------------------
_disable_cart_eject_irq:
	PUSH EP
	PUSH BR
	CARL set_br
	AND [BR:24h], #~02h                 ; disable cart eject IRQ
	POP BR
	POP EP
	RETE
; ----------------------
_unknown_eject4:
	POP SC
	PUSH EP
	PUSH BR
	PUSH BA
	CARL set_br
	LD A, SC                            ; get C and Z
	SRL A                               ; ...shift to top two bits
	SRL A                               ; ...
	AND A, #30h                         ; ...
	LD B, [BR:21h]                      ; compare with clock timer IRQs' priority
	AND B, #30h                         ; ...
	CP A, B                             ; ...
	XOR SC, #01h                        ; invert Z, so 0 = not equal
	JRS Z, loc_0x0AA2                   ; return if they're not equal
	BIT [BR:28h], #02h                  ; check if cart eject fired
	JRS Z, loc_0x0AA2                   ; if not, return
	LD [BR:28h], #02h                   ; if so, clear
loc_0x0AA2:
	POP BA
	POP BR
	POP EP
	RET
; ----------------------
_enter_high_speed_operation:
	PUSH EP
	PUSH BR
	CARL set_br
	LD SC, #0C0h                        ; interrupt flags to NMI-only
	CARS enter_high_speed_operation
	POP BR
	POP EP
	RETE
enter_high_speed_operation:
	PUSH IX
	AND [BR:02h], #~01h                 ; write 00 (intended) to VD1C (mid operating voltage)
	LD IX, #20                          ; wait 83 cycles
ehso__wait_80:
	DEC IX
	JRS NZ, ehso__wait_80
	OR [BR:02h], #04h                   ; write 1 to OSCC
	LD IX, #409                         ; wait 1639 cycles
ehso__wait_1636:
	DEC IX
	JRS NZ, ehso__wait_1636
	OR [BR:02h], #08h                   ; clock CPU with OSC3
	OR [BR:02h], #10h                   ; ??
	POP IX
	RET
; ----------------------
_enter_low_speed_operation:
	PUSH EP
	PUSH BR
	CARL set_br
	LD SC, #0C0h                        ; interrupt flags to NMI-only
	CARS enter_low_speed_operation
	POP BR
	POP EP
	RETE
enter_low_speed_operation:
	AND [BR:02h], #~10h                 ; ??
	AND [BR:02h], #~08h                 ; clock CPU with OSC1
	AND [BR:02h], #~04h                 ; turn off OSC3
	OR [BR:02h], #01h                   ; write 01 (intended) to VD1C (lowest operating voltage)
	RET
; ----------------------
_cart_slot_off:
	PUSH EP
	PUSH BR
	CARL set_br
	LD SC, #0C0h                        ; interrupt flags to NMI-only
	CARS cart_slot_off
	POP BR
	POP EP
	RETE
; ----------------------
cart_slot_off:
	AND [BR:02h], #~40h
unpower_cart:
	OR [BR:71h], #04h                   ; turn off cart power
	RET
; ----------------------
_cart_slot_on:
	PUSH EP
	PUSH BR
	CARL set_br
	LD SC, #0C0h                        ; interrupt flags to NMI-only
	CARS cart_slot_on
	POP BR
	POP EP
	RETE
cart_slot_on:
	OR [BR:02h], #40h                   ; ??
power_cart:
	PUSH IX
	PUSH BA
	AND [BR:71h], #~04h                 ; power the cart
	OR [BR:02h], #80h                   ; ??
	LD IX, #0032h                       ; wait for 203 cycles
pc__wait_200:
	DEC IX
	JRS NZ, pc__wait_200
	LD A, [2AAAh]                       ; dummy read to cancel any half-input flash commands
	OR [BR:02h], #80h                   ; ??
	POP BA
	POP IX
	RET
; ----------------------
; Returns
;   Z: 1=cart is inserted
_cart_detect:
	POP SC
	PUSH EP
	PUSH BR
	CARL set_br
	BIT [BR:53h], #02h
	XOR SC, #01h
	POP BR
	POP EP
	RET
; ----------------------
; Arguments:
;   IX: start address of structure
_read_structure:
	PUSH EP                             ; omg just use PUSH ALE
	PUSH BR
	CARL set_br
	PUSH IP
	PUSH IX
	PUSH IY
	PUSH HL
	PUSH B
	LD SC, #0C0h                        ; interrupt flags to NMI-only
	LD A, [IX]                          ; read byte $00
	BIT A, #01h                         ; if bit 0 is 0,
	LD A, SC                            ; (save result for later)
	JRS Z, loc_0x0B4E                   ;
	ADD IX, #000Ah                      ; read byte $0A
	LD H, [IX]                          ; ...
	DEC IX                              ; read byte $09
	LD L, [IX]                          ; ...
	DEC IX                              ; read byte $08
	PUSH HL
	LD B, [IX]                          ; ...
	DEC IX                              ; addr $07
	JRS loc_0x0B51
loc_0x0B4E:
	ADD IX, #0007h                      ; addr $07
loc_0x0B51:
	PUSH BA
	LD B, [IX]                          ; read byte $07
	DEC IX                              ; read byte $06
	LD A, [IX]                          ; ...
	DEC IX                              ; read byte $05
	LD H, [IX]                          ; ...
	DEC IX                              ; read byte $04
	LD L, [IX]                          ; ...
	DEC IX                              ; addr $03
	LD YP, A                            ; byte $06 to YP
	LD IY, HL                           ; bytes $05~04 to IY
	LD A, [IX]                          ; read byte $03
	DEC IX                              ; read byte $02
	LD H, [IX]                          ; ...
	DEC IX                              ; read byte $01
	LD L, [IX]                          ; ...
	LD XP, A                            ; byte $03 to XP, why is this necessary?
	LD IX, HL                           ; bytes $02~$01 to IX
	OR [BR:02h], #80h                   ; ??
	LD [IX], #0FFh                      ; write 0xFF to IX
	OR [BR:02h], #80h                   ; ???
	LD A, [IY]                          ; read byte into A
	OR [BR:02h], #80h                   ; ????
	CP A, B                             ; compare with byte $07
	POP BA                              ; restore B=byte $08, A=state of byte $00 bit 0
	PUSH SC                             ; store result of CP
	LD SC, A                            ; re-check byte $00 bit 0
	JRS Z, loc_0x0B82                   ; which allows B to definitely be byte $08
	POP SC                              ; just popped to allow POP BA
	LD L, B                             ; L=byte $08
	POP BA                              ; (from $0B49) B=byte $0A, A=byte $09
	LD H, A                             ; H=byte $09
	LD A, B                             ; A=byte $0A
	PUSH SC                             ; pushed back to stack unchanged
	; subroutine should fetch [SP+3] for the result of
	; the compare then put its result in its place
	CARS call_a_hl
loc_0x0B82:
	POP BA                              ; B=B before call, A=SC from $0B75 or $0B7F
	AND A, #01h                         ; A=Z, result of compare with byte $07
	POP HL
	POP IY
	POP IX
	POP IP
	POP BR
	POP EP
	RETE
; ----------------------
; Used by _read_structure
; Arguments
;   A: code page
;   HL: subroutine address
;   [SP+3]: compare byte result (from SC)
; Clobbers: any/all
call_a_hl:
	LD NB, A
	JP HL
; ----------------------
; Arguments
;   A: rate divider
_set_prc_rate:
	PUSH EP
	PUSH HL
	AND A, #07h                         ; limit to 3 bits
	SLL A                               ; position
	LD EP, #00h
	LD HL, #2081h
	AND [HL], #0F1h                     ; reset those bits
	OR [HL], A                          ; insert new value
	POP HL
	POP EP
	RETE
; ----------------------
; Returns
;   A: rate divider value
_get_prc_rate:
	PUSH EP
	PUSH BR
	CARL set_br
	LD A, [BR:81h]
	AND A, #0Eh
	SRL A
	POP BR
	POP EP
	RETE
; ----------------------
; This has to do with the Game Select screen
; Returns
;   Z: 1=$2001 bits 2~0 are a valid game index
_game_id_valid:
	POP SC
	PUSH EP
	PUSH BR
	CARL set_br
	BIT [BR:01h], #08h
	POP BR
	POP EP
	RET
; ----------------------
; Write to IR bit, wait, then reset IR bit
; Arguments:
;   IY = $2061
;   B = cycles to wait / 4
_ir_pulse:
	LD [IY], #02h
irp__wait:
	DJR NZ, irp__wait
	LD [IY], #00h
	RETE
; ----------------------
; Set [BR:ll] indexing for hardware registers.
; Returns:
;   EP: page for [BR:ll] (set to 0)
;   BR: BR set to $20 for hardware register space
set_br:
	LD EP, #00h
	LD BR, #20h
	RET
; ----------------------
wait_8000_cycles:                       ; including the CARL to get here
	PUSH IX
	LD IX, #1995
w8kc__loop:
	DEC IX
	JRS NZ, w8kc__loop
	POP IX
	RET
; ----------------------
; Arguments:
;   H: previous inverted keypad state
; Returns:
;   A: newly pressed keys
;   H: keys being pressed, new or old
; Clobbers: B
read_keys_buffer:
	LD B, [BR:52h]                      ; read current keymap state
	CPL B                               ; invert so 1 is pressed
	LD A, H
	LD H, B
	XOR A, B                            ; 0 out any keys that were pressed last time
	AND A, B                            ; ...
	RET
; ----------------------
; Arguments:
;   IY: tilemap source
; Returns:
;   IX: $1360 (start of tilemap memory)
; Clobbers: L
load_tilemap:
	LD IX, #1360h                       ; tilemap base
	LD L, #00h                          ; loop 0 to 96 (exclusive), a full 12x8 screen
ltm__loop:
	LD B, [IY+L]                        ; read from map starting at IY
	LD [IX+L], B                        ; copy into IX
	INC L
	CP L, #60h
	JRS NZ, ltm__loop
	RET
; ----------------------
; Arguments:
;   IY: tilemap source
; Returns:
;   IX: $1378 (top of names list)
; Clobbers: L
load_middle_5_tilemap:                  ; middle 5 rows
	LD IX, #1378h                       ; start of row 2 (0-based)
	LD L, #00h                          ; loop from 0 to 60 (exclusive), a 12x5 subsection
	AND [BR:80h], #~08h                 ; disable LCD controller
lm5tm__loop:
	LD B, [IY+L]                        ; read from map starting at IY
	LD [IX+L], B                        ; copy into IX
	INC L
	CP L, #3Ch
	JRS NZ, lm5tm__loop
	RET
; ----------------------
; Copy one frame while the LCD controller is disabled
; Will disable it again by the end of the function
copy_one_frame:
	LD [BR:27h], #80h                   ; clear Frame Copy Complete
	OR [BR:80h], #08h                   ; enable frame copy
cof__wait_for_vsync:
	BIT [BR:27h], #80h                  ; wait for Frame Copy Complete to trigger
	JRS Z, cof__wait_for_vsync
	AND [BR:80h], #~08h                 ; disable LCD controller
	RET
; ----------------------
; Arguments:
;   A: number of game structs loaded
; Clobbers: B, HL, IX, IY
game_select_screen:
	DEC A                               ; get starting index of final row
	LD L, #12                           ; ...a row is 12 tiles wide (screen width)
	MLT                                 ; ...
	LD [FinalNameRowStart], L           ; ...
	CP L, #48                           ; if L < 48,
	JRS C, gss__min_final
	LD L, #48                           ; 48 is the start of the 5th entry, basing 0 at the first entry
gss__min_final:
	LD [FinalNameRowStartMin48], L
	LD IY, #GameSelectMap               ; load the base tilemap (not the five name lines)
	CARL load_tilemap
	LD IX, #CurrentRowStart
	LD IY, #MoveCooldown
	XOR A, A
	LD [KeyHistory], A                  ; no keys pressed
	LD A, [BR:52h]                      ; take cpl of keymap (so 1=pressed)
	CPL A                               ; ...
	LD H, A                             ; ...into H
	XOR A, A                            ; draw names from first name
	LD L, A                             ; with the first name selected
	LD [IX], A                          ; CurrentRowStart = 0
	CARL draw_game_names
gss__main_loop:
	LD [BR:27h], #40h                   ; clear frame divided overflow
gss__ml__wait_for_framediv_overflow:
	BIT [BR:27h], #40h
	JRS Z, gss__ml__wait_for_framediv_overflow
	CARL init_display_without_wait
	CARL apply_default_contrast1
	CARL read_keys_buffer
	LD B, A
	LD A, [KeyHistory]                  ; update key history with newly pressed keys
	OR A, B                             ; ...
	LD [KeyHistory], A                  ; ...
	EX A, B                             ; (after EX) A=new keys, B=updated key history
	OR A, A                             ; if any new keys were pressed
	JRS Z, gss__ml__no_new_keys
	LD [IY], #13                        ; start cooldown at 13 frames
	JRS gss__ml__continue
gss__ml__no_new_keys:
	LD A, H                             ; if we're still pressing a key we've (ever) pressed before
	AND A, B                            ; (including any pressed this frame),
	JRS Z, gss__ml__wait_for_keyup
	LD B, [IY]                          ; decrement cooldown
	DEC B                               ; ...
	LD [IY], B                          ; ...
	JRS NZ, gss__ml__wait_for_keyup     ; and wait until we're not
	LD [IY], #5                         ; reset cooldown to 5 frames
gss__ml__continue:
	CARL gss__check_keys
gss__ml__wait_for_keyup:
	JRS gss__main_loop
; ----------------------
gss__check_keys:
	BIT A, #05h                         ; check if A or C was pressed
	JRS Z, gss__ck__back
	LD H, #0                            ; divide selected row tile index
	LD A, #12                           ; ...by the screen width
	DIV                                 ; ...to get the game index
	LD A, L                             ; ...and store it in A
	AND [BR:80h], #~08h                 ; disable LCD controller
	LD IY, #BlankTilemap                ; load the blank tilemap
	CARL load_tilemap                   ; ...
	CARL copy_one_frame                 ; draw it to screen
	JRL run_selected_game               ; boot the game
gss__ck__back:
	BIT A, #82h                         ; check if power or B button was pressed
	JRS Z, gss__ck__up
	JRL shutdown
gss__ck__up:
	BIT A, #08h                         ; check if up button was pressed
	JRS Z, gss__ck__down
	LD A, L                             ; if selected row tile index
	OR A, A                             ; ...is not the first row,
	JRS Z, gss__ck__return
	SUB A, #12                          ; then move the cursor up 1 row (12 tiles)
	LD L, A                             ; ...
	OR A, A                             ; if it's the first now,
	LD A, [IX]                          ; (A = CurrentRowStart)
	JRS Z, gss__ck__redraw2             ; then redraw
	LD B, L                             ; if the top visible row changed,
	CP A, B                             ; ...
	JRS NZ, gss__ck__redraw2            ; then redraw
	SUB A, #12                          ; otherwise, move the top up one
	LD [IX], A                          ; ...
gss__ck__redraw2:
	JRS gss__ck__redraw
gss__ck__down:
	BIT A, #10h                         ; check if down button was pressed
	JRS Z, gss__ck__return
	LD A, L                             ; if the selected row
	LD B, [FinalNameRowStart]           ; ...is not the final row,
	CP A, B                             ; ...
	JRS Z, gss__ck__return
	ADD A, #12                          ; then move the cursor down 1 row (12 tiles)
	LD L, A                             ; ...
	CP A, B                             ; if it's now the final row,
	LD A, [IX]                          ; (A = CurrentRowStart)
	JRS Z, gss__ck__redraw              ; then redraw
	ADD A, [FinalNameRowStartMin48]     ; otherwise if it's at the bottom of the list,
	LD B, L                             ; ...
	CP A, B                             ; ...
	LD A, [IX]                          ; (A = CurrentRowStart)
	JRS NZ, gss__ck__redraw
	ADD A, #12                          ; then move the top down 1 row
	LD [IX], A
gss__ck__redraw:
	CARL draw_game_names
gss__ck__return:
	RET
; ----------------------
; Arguments
;   L: selected row in tiles from absolute top of names
;   A: top of visible names as tile index
draw_game_names:
	PUSH HL
	PUSH IX
	PUSH IY
	LD H, L
	LD IY, #GameNamesMap                ; game select tilemap, names section
	LD B, #00h
	ADD IY, BA                          ; scroll to top of screen
	CARL load_middle_5_tilemap          ; draw names
	LD IY, #1372h                       ; tile 18 (6,1)
	OR A, A                             ; if a is at the top,
	JRS Z, dgn__list_is_at_top          ; don't show an up arrow
	LD [IY], #21h                       ; draw "up arrow with line above" tile
	JRS dgn__check_list_bottom
dgn__list_is_at_top:
	LD [IY], #1Fh                       ; draw "line above without arrow" tile
dgn__check_list_bottom:
	LD B, A
	ADD A, [FinalNameRowStartMin48]     ; add visible rows (up to 12*4=48)
	LD IY, #13BAh                       ; tile 90 (6,7)
	CP A, [FinalNameRowStart]           ; if that is the last row,
	JRS Z, dgn__list_is_at_bottom       ; don't show a down arrow
	LD [IY], #2Ch                       ; draw "down arrow with line below" tile
	JRS dgn__draw_cursor
dgn__list_is_at_bottom:
	LD [IY], #2Ah                       ; draw "line below without arrow" tile
dgn__draw_cursor:
	LD A, H                             ; calculate position of selection arrow
	SUB A, B                            ; ...
	ADD A, #01h                         ; ...
	LD B, #00h                          ; ...
	ADD IX, BA                          ; ...
	LD [IX], #0Bh                       ; draw selection arrow tile
	OR [BR:80h], #08h                   ; re-enable frame copy
	POP IY
	POP IX
	POP HL
	RET
; ----------------------
; Arguments:
;   IX: start of animation footer
;   IY: start of animation data
; Returns:
;   Z: 0=animation ended, 1=key pressed
;   A: 0=animation ended, otherwise keys that were pressed
; Clobbers: B, HL
play_animation:
	PUSH IX
	PUSH IY
	LD IY, #BlankTilemap
	CARL load_tilemap
	POP IY
	POP IX                              ; read in the footer
	LD A, [IX]                          ; length in rendered frames (lo byte)
	INC IX                              ; size in bytes of animation info
	LD B, [IX]                          ; and 1 hi bit for length
	SRL B                               ; put length's hi bit in C
	LD L, B                             ; store the size in L
	LD B, #00h                          ; put hi bit of total frame count back into b
	RL B                                ; ...
	LD IX, #TotalAnimFrames             ; store total frame count
	LD [IX], BA                         ; ...as remaining frames to render
	LD [BR:27h], #40h                   ; clear frame divider overflow
pa__wait_for_framediv_overflow:
	BIT [BR:27h], #40h
	JRS Z, pa__wait_for_framediv_overflow
	LD [BR:27h], #40h                   ; clear frame divider overflow
	LD A, [BR:52h]                      ; take cpl of keymap (so 1=pressed)
	CPL A                               ; ...
	LD H, A                             ; ...into H
	PUSH L                              ; backup size of animation data
pa__read_loop:
	DEC L                               ; reading bytes right-to-left
	LD B, [IY+L]                        ; frame count + hi bit of addr
	DEC L
	LD A, [IY+L]                        ; map address offset (lo)
	JRS NZ, pa__not_done_reading
	POP L                               ; return to first frame if we finished reading
	PUSH L                              ; ...
pa__not_done_reading:
	SRL B
	LD [FramesRemaining], B             ; store frame count here
	LD B, #00h                          ; map address offset hi bit back into b
	RL B                                ; ...
	PUSH HL
	PUSH IX
	PUSH IY
	LD IY, #InsertCartMaps              ; load selected frame
	ADD IY, BA                          ; offset from the base address
	CARL load_middle_5_tilemap
	OR [BR:80h], #08h                   ; enable LCD controller
	POP IY
	POP IX
	POP HL
pa__draw_again:
pa__wait_for_framediv_overflow2:
	BIT [BR:27h], #40h
	JRS Z, pa__wait_for_framediv_overflow2
	LD [BR:27h], #40h                   ; clear frame divider overflow
	CARL init_display_without_wait
	CARL apply_default_contrast1
	CARL read_keys_buffer               ; read keys excluding anything pressed down since before animation started
	BIT A, #87h                         ; if power, A, B, or C is being pressed,
	JRS NZ, pa__return                  ; break
pa__continue_playing:
	LD BA, [IX]                         ; decrement total rendered frames remaining
	DEC BA                              ; ...
	LD [IX], BA                         ; ...
	JRS Z, pa__return                   ; break if none left
	LD A, [FramesRemaining]             ; decrement rendered frames remaining for this image
	DEC A                               ; ...
	LD [FramesRemaining], A             ; ...
	JRS NZ, pa__draw_again              ; if there's more to render, keep drawing
	JRS pa__read_loop
pa__return:
	POP B                               ; first frame's source addr offset
	RET
; ----------------------
; Play low battery animation and check key presses.
; A/C -> skip shutdown, play software anyway
; B/Power -> shutdown early
; Assumes XP/YP = $00
; Clobbers: BA, HL, IX, IY
low_battery_screen:
	LD IX, #low_battery_animation_footer
	LD IY, #low_battery_animation
	CARL play_animation
	JRS Z, lbs__skip_shutdown           ; if animation finished, don't shutdown
	BIT A, #82h                         ; if A or C was pressed,
	JRS Z, lbs__skip_shutdown           ; don't shutdown
	JRL shutdown
lbs__skip_shutdown:
	AND [BR:80h], #~08h                 ; disable LCD controller
	LD IY, #BlankTilemap                ; load blank screen for one frame
	CARL load_tilemap                   ; ...
	CARL copy_one_frame                 ; ...force draws it despite the shutoff
	RET
; ----------------------
; Play low battery animation and check key presses.
; A/C -> check for cartridge again
; B/Power -> shutdown early
; Assumes XP/YP = $00
; Clobbers: any
insert_cart_screen:
	LD SC, #0C0h                        ; interrupt flags to NMI-only
	OR [BR:71h], #04h                   ; cart power off
	LD IX, insert_cart_animation_footer
	LD IY, insert_cart_animation
	CARL play_animation
ics__check_loop:
	JRS Z, ics__shutdown                ; if animation finished, shutdown
	BIT A, #82h                         ; if power or B key was pressed,
	JRS NZ, ics__shutdown               ; shutdown
	BIT [BR:53h], #02h                  ; if card was inserted,
	JRL Z, _reset2                      ; reset to boot it
	CARS ics__continue_playing
	JRS ics__check_loop
ics__shutdown:
	JRL shutdown
ics__continue_playing:
	PUSH B
	JRL pa__continue_playing
; ----------------------
; Decode encoded maps and graphics from imgdata to RAM
; Clobbers: BA, L, IX, IY
decode_picture:
	LD IY, #imgdata                     ; source
	LD IX, #BlankTilemap                ; destination
dp__loop:
	LD A, [IY]                          ; read encoded byte
	INC IY                              ; increment offset
	CP A, #0F9h                         ; compare value to 0xF9
	JRS NZ, dp__checkFB                 ; if it isn't, jump
	LD B, [IY]                          ; value after F9 is number of 0s to fill - 1
	INC IY                              ; inc offset
	INC B                               ; add 1 to find actual number of 0s
	XOR A, A                            ; set A to 0
dp__zero_fill_loop:
	LD [IX], A                          ; store 0 in destination offset
	INC IX                              ; inc dest offset
	DJR NZ, dp__zero_fill_loop          ; dec B and loop if not 0
	JRS dp__continue
dp__checkFB:
	CP A, #0FBh                         ; compare value to 0xFB
	JRS NZ, dp__raw_byte                ; if it's not, continue as normal byte to write
	LD A, [IY]                          ; otherwise, store next source byte in A
	INC IY                              ; inc offset
	LD B, [IY]                          ; next source byte into B
	INC IY                              ; increment source offset
	INC B                               ; and B
dp__fill_loop:
	LD [IX], A                          ; store A in destination offset
	INC IX                              ; increment destination
	DJR NZ, dp__fill_loop               ; dec B and loop if not 0
	JRS dp__continue                    ; end of fill section
dp__raw_byte:
	LD [IX], A                          ; store A in destination offset
	INC IX                              ; increment destination offset
dp__continue:
	CP IY, #1000h                       ; if not all 0x1C0 bytes have been decoded yet,
	JRS NZ, dp__loop                    ; go back to the decode loop
	LD IX, #VFlipStart                  ; tile gfx for top left corner of game select border
	LD IY, #VFlippedTiles               ; the first byte after the decoded data
	; v-flip and append last 11 tiles
dp__vflip_loop:
	LD A, [IX]                          ; load one byte of tile data
	LD L, #8                            ; 8 bits
dp__vflip_byte:
	RL A                                ; pop top bit of tile data
	RR B                                ; pushed onto top bit of B
	DEC L
	JRS NZ, dp__vflip_byte
	LD [IY], B                          ; store flipped data
	INC IX                              ; next source addr
	INC IY                              ; next destination addr
	CP IX, #VFlippedTiles               ; since they're sequential, if IX makes it here we're done flipping
	JRS NZ, dp__vflip_loop
	RET
; ----------------------
	DB 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh
; ----------------------
nintendo_string:
	ASCII "NINTENDO"
; ----------------------
; Format is backwards, starting at the right and going left.
; Each image of the animation is two bytes of the form:
;   map address (lo), 0bLLLLLLLH
;   L = length in rendered frames
;   H = map address (hi)
; The map address is an offset from $1650
; The footer is two bytes of the form:
;   length (lo), 0bNNNNNNNH
;   N = number of bytes in the animation info
;   H = length (hi)
low_battery_animation:
	DB 68h, 6Fh, 0A4h, 13h, 68h, 13h, 0A4h, 13h, 68h, 13h, 0A4h, 13h, 68h, 13h, 2Ch, 13h
	DB 0F0h, 12h, 0B4h, 12h
low_battery_animation_footer:
	DB 98h, 29h

insert_cart_animation:
	DB 78h, 0Ch, 3Ch, 18h, 00h, 3Ch
insert_cart_animation_footer:
	DB 20h, 0Dh

; Simple RLE compression algorithm:
; 0xF9LL inserts LL+1 zeroes
; 0xFBXXLL inserts the byte 0xXX LL+1 times
; otherwise it copies the raw byte
imgdata:
	; Blank tilemap starting at $1530
	DB 0F9h, 60h

	; Including one zero byte from above, the GAME SELECT screen's rows 0,1,7
	DB        01h, 02h, 03h, 04h, 05h, 06h, 07h, 08h, 09h, 0Ah, 00h
	DB  1Eh, 0FBh, 1Fh, 09h,                                    20h
	DB 0F9h,  3Bh
	DB  29h, 0FBh, 2Ah, 09h,                                    2Bh

	; The GAME SELECT screen's middle 5 rows (two pages?)
	DB 0Ch, 00h, 34h, 35h, 36h, 37h, 38h, 39h, 3Ah, 3Bh, 3Ch, 0Dh
	DB 0Ch, 00h, 3Dh, 3Eh, 3Fh, 40h, 41h, 42h, 43h, 44h, 45h, 0Dh
	DB 0Ch, 00h, 46h, 47h, 48h, 49h, 4Ah, 4Bh, 4Ch, 4Dh, 4Eh, 0Dh
	DB 0Ch, 00h, 4Fh, 50h, 51h, 52h, 53h, 54h, 55h, 56h, 57h, 0Dh
	DB 0Ch, 00h, 58h, 59h, 5Ah, 5Bh, 5Ch, 5Dh, 5Eh, 5Fh, 60h, 0Dh
	DB 0Ch, 00h, 61h, 62h, 63h, 64h, 65h, 66h, 67h, 68h, 69h, 0Dh
	DB 0Ch, 00h, 6Ah, 6Bh, 6Ch, 6Dh, 6Eh, 6Fh, 70h, 71h, 72h, 0Dh
	DB 0Ch, 00h, 73h, 74h, 75h, 76h, 77h, 78h, 79h, 7Ah, 7Bh, 0Dh

	; Insert cart animation maps
	DB 0F9h, 0Fh, 12h, 13h, 14h, 15h ; Frame 1
	DB 0F9h, 07h, 16h, 17h, 18h, 19h
	DB 0F9h, 07h, 1Ah, 1Bh, 1Ch, 1Dh
	DB 0F9h, 14h, 0Eh, 0Fh           ; Frame 2
	DB 0F9h, 08h, 12h, 13h, 14h, 15h
	DB 0F9h, 07h, 16h, 17h, 18h, 19h
	DB 0F9h, 07h, 1Ah, 1Bh, 1Ch, 1Dh
	DB 0F9h, 14h, 10h, 11h           ; Frame 3
	DB 0F9h, 08h, 12h, 13h, 14h, 15h
	DB 0F9h, 07h, 16h, 17h, 18h, 19h
	DB 0F9h, 07h, 1Ah, 1Bh, 1Ch, 1Dh

	; Low battery animation maps
	DB 0F9h, 1Fh, 22h, 23h, 23h, 24h ; Frame 1
	DB 0F9h, 07h, 2Dh, 2Eh, 2Eh, 2Fh
	DB 0F9h, 2Bh, 25h, 26h, 23h, 24h ; Frame 2
	DB 0F9h, 07h, 30h, 31h, 2Eh, 2Fh
	DB 0F9h, 2Bh, 25h, 27h, 26h, 24h ; Frame 3
	DB 0F9h, 07h, 30h, 32h, 31h, 2Fh
	DB 0F9h, 2Bh, 25h, 27h, 27h, 28h ; Frame 4, 6, 8, 10
	DB 0F9h, 07h, 30h, 32h, 32h, 33h
	DB 0F9h, 65h                     ; Frame 5, 7, 9 (+ some 0s from below)

	; Tile graphics
	;DB                                               ; tile  0: blank
	DB                                     07Ch, 0FEh ; tile  1: start of G
	DB 082h, 092h, 0F6h, 074h, 000h, 0F0h, 0FCh, 026h ; tile  2: GA
	DB 026h, 0FCh, 0F0h, 000h, 0FEh, 0FEh, 008h, 010h ; tile  3: AM
	DB 008h, 0FEh, 0FEh, 000h, 0FEh, 0FEh, 092h, 092h ; tile  4: ME
	DB 092h, 0F9h, 003h,             0CCh, 0DEh, 092h ; tile  5: ES
	DB 0F6h, 066h, 000h, 0FEh, 0FEh, 092h, 092h, 092h ; tile  6: SE
	DB 000h, 0FEh, 0FEh, 080h, 080h, 080h, 000h, 0FEh ; tile  7: LE
	DB 0FEh, 092h, 092h, 092h, 000h, 07Ch, 0FEh, 082h ; tile  8: EC
	DB 082h, 0C6h, 044h, 000h, 002h, 002h, 0FEh, 0FEh ; tile  9: CT
	DB 002h, 002h, 0F9h, 007h                         ; tile 10: T
	DB             0FEh, 07Ch, 038h, 010h, 0F9h, 005h ; tile 11: select arrow
	DB                         0FFh, 0F9h, 005h       ; tile 12: left side of border
	DB                   0FFh, 0F9h, 004h             ; tile 13: right side of border
	DB       0F0h, 0FBh, 008h, 00Bh                   ; tile 14: extended cartridge left
	DB                                     0F0h, 000h ; tile 15: extended cartridge right
	DB 000h, 080h, 0FBh, 040h, 00Bh                   ; tile 16: inserted cartridge left
	DB                                     080h, 0F9h ; tile 17: inserted cartridge right
	DB 006h,                               0F8h, 004h ; tile 18: PM (0,0)
	DB 082h, 0E1h, 0E1h, 031h, 031h, 0FBh, 039h, 005h ; tile 19: PM (1,0)
	DB                   031h, 031h, 0E1h, 0E1h, 082h ; tile 20: PM (2,0)
	DB 006h, 0FAh, 004h, 0F8h, 0F9h, 008h             ; tile 21: PM (3,0)
	DB                               0FCh, 003h, 000h ; tile 22: PM (0,1)
	DB 007h, 0DFh, 0DFh, 030h, 030h, 0FBh, 070h, 005h ; tile 23: PM (1,1)
	DB                   030h, 030h, 01Fh, 09Fh, 087h ; tile 24: PM (2,1)
	DB 000h, 003h, 0FDh, 0F9h, 009h                   ; tile 25: PM (3,1)
	DB                               007h, 008h, 013h ; tile 26: PM (0,2)
	DB 013h, 02Fh, 02Fh, 023h, 023h, 0FBh, 020h, 005h ; tile 27: PM (1,2)
	DB                   046h, 046h, 040h, 081h, 081h ; tile 28: PM (2,2)
	DB 080h, 040h, 03Fh, 0F9h, 008h                   ; tile 29: PM (3,2)
	DB                         0FEh, 0FBh, 002h, 00Dh ; tile 30: top left corner of border
	;DB                                               ; tile 31: top side of border
	DB                   0FEh, 0F9h, 003h             ; tile 32: top right corner of border
	DB 002h, 022h, 032h, 03Ah, 03Ah, 032h, 022h, 002h ; tile 33: more games upward arrow
	DB 0E0h, 020h, 0BCh, 084h, 0F4h, 0F4h, 004h, 0F4h ; tile 34: full battery top left
	DB 0F4h, 0F4h, 004h, 0F4h, 0F4h, 0F4h, 004h, 0F4h ; tile 35: full battery top middle
	DB 0F4h, 0F4h, 004h, 0F4h, 0F4h, 0F4h, 004h, 0FCh ; tile 36: full battery top right
	DB 0E0h, 020h, 03Ch, 0FBh, 004h, 007h             ; tile 37: empty battery top left
	DB                   0F4h, 0F4h, 0F4h, 004h, 0F4h ; tile 38: drained battery top middle
	DB 0FBh, 004h, 00Ah                               ; tile 39: empty battery top middle
	DB                   0F4h, 0F4h, 0F4h, 004h, 0FCh ; tile 40: drained battery top right
	; tiles 41-51 (inclusive) are v-flipped versions
	; of 30-40 which are generated at runtime
{%- endasm %}
